{"version":3,"sources":["constants/tile-constants.js","components/download-dropdown.js","constants/palette-constants.js","components/palette-color-preview.js","components/palette-preview.js","components/tile-setting.js","components/tiled-image.js","components/map-preview-button.js","App.js","reportWebVitals.js","index.js","services/image-generator.js"],"names":["IMAGE_WIDTH","IMAGE_HEIGHT","AVAILABLE_TILE_TYPES","DEFAULT_TILE_TYPE","TILE_BACKGROUND_COLORS","grass","water","lava","rock","brick","hole","plant","block","sand","bridge","ladder","stairs","tile","TILE_NAMES","TILE_PREVIEW_IDS","TILE_OPTIONS","name","type","defaultValue","min","max","disabled","step","TILE_PREVIEW_MAP","MapPreviewButton","TextDecoder","props","state","data","a","document","createElement","href","download","click","ImageGenerator","generateFullSet","this","tileImages","img","forceDownload","organizeIntoBlocks","generateNesPatternTables","tileProps","b64data","Buffer","from","toString","Uint8Array","nesPaletteData","caret","slot","title","onClick","downloadAll","downloadBin","downloadPalette","React","Component","availablePalettes","paletteData","getPalette","idOrName","PaletteColorPreview","className","style","backgroundColor","color","PalettePreview","palette","map","padStart","TileSetting","setting","tileTypeId","updateTileState","reloadFromProps","nextProps","setState","b","c","label","value","onSlChange","e","target","n","checked","console","error","TiledImage","allSrc","tileId","id","src","i","alt","imageRef","createRef","mapImage","generateMapPreview","current","show","content","showDialog","ref","App","tileType","currentTileImg","builtTileImages","forEach","t","opt","undefined","val","Math","floor","random","lastTileType","localStorage","getItem","info","length","generateTileImage","reloadImage","newState","force","Palette","generateImage","res","getCurrentTileImage","event","setItem","typeName","reRandomize","updateTileType","process","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById","modulus","getRandomImageCoords","image","x","bitmap","width","y","height","tileOpt","Promise","resolve","reject","Jimp","err","drawGrass","drawWater","drawBrick","drawBlock","drawHole","drawPlant","drawRock","drawLava","drawSand","drawBridge","drawLadder","drawStairs","warn","getBase64Async","setPixelColor","originX","originY","depthR","scan","idx","dx","dy","xDiff","yDiff","row1Lines","row2Lines","push","rowNum","indexOf","tileSize","h","borderWidth","fuzzWidth","angle","x1","y1","r","cos","PI","sin","round","imgY","hitLeft","hitMid","hitRight","colorCount","imgX","getPixelColor","shadowX","freckleCount","fx","fy","coords","fxx","fyy","read","rockImg","blit","frequency","offset","waveWidth","abs","currColor","stepHeight","thisB64","substr","imageState","imageFromBase64","thisImg","sqrt","drawState","pos","notDrawn","filter","join","ppuData","tileColorData","Array","paletteColors","bits0","bits1","thisTileBp1a","thisTileBp2a","thisTileBp1b","thisTileBp2b","thisTileBp3a","thisTileBp3b","thisTileBp4a","thisTileBp4b","bitplaneNum","j","k","organizedArray","fill","position","originalPosition"],"mappings":"iIAAA,kTAAO,IAAMA,EAAc,GACdC,EAAe,GAEfC,EAAuB,CAClC,QACA,QACA,SACA,QACA,QACA,OACA,SACA,OACA,OACA,OACA,SACA,OACA,SAGWC,EAAoB,QAEpBC,EAAyB,CACpCC,MAAO,EACPC,MAAO,EACPC,KAAM,EACNC,KAAM,EACNC,MAAO,EACPC,KAAM,EACNC,MAAO,EACPC,MAAO,EACPC,KAAM,EACNC,OAAQ,EACRC,OAAQ,EACRC,OAAQ,EACRC,KAAM,GAGKC,EAAa,CACxBb,MAAO,QACPC,MAAO,QACPC,KAAM,OACNK,MAAO,QACPH,MAAO,aACPD,KAAM,OACNE,KAAM,aACNC,MAAO,OACPE,KAAM,OACNC,OAAQ,SACRC,OAAQ,SACRC,OAAQ,SACRC,KAAM,QAGKE,EAAmB,CAC9Bd,MAAO,CACL,QAAS,QAAS,QAClB,QAAS,QAAS,QAClB,QAAS,QAAS,SAEpBC,MAAO,CACL,QAAS,QAAS,QAClB,QAAS,QAAS,QAClB,QAAS,QAAS,SAEpBC,KAAM,CACJ,OAAQ,OAAQ,OAChB,OAAQ,OAAQ,OAChB,OAAQ,OAAQ,QAElBK,MAAO,CACL,QAAS,QAAS,QAClB,QAAS,QAAS,QAClB,QAAS,QAAS,SAEpBH,MAAO,CACL,QAAS,QAAS,QAClB,QAAS,QAAS,QAClB,QAAS,QAAS,SAEpBD,KAAM,CACJ,OAAQ,OAAQ,OAChB,OAAQ,OAAQ,OAChB,OAAQ,OAAQ,QAElBE,KAAM,CACJ,OAAQ,OAAQ,OAChB,OAAQ,OAAQ,OAChB,OAAQ,OAAQ,QAElBC,MAAO,CACL,QAAS,QAAS,QAClB,QAAS,QAAS,QAClB,QAAS,QAAS,SAEpBE,KAAM,CACJ,OAAQ,OAAQ,OAChB,OAAQ,OAAQ,OAChB,OAAQ,OAAQ,QAElBC,OAAQ,CACN,QAAS,QAAS,QAClB,SAAU,SAAU,SACpB,QAAS,QAAS,SAEpBC,OAAQ,CACN,OAAQ,SAAU,OAClB,OAAQ,SAAU,OAClB,QAAS,QAAS,SAEpBC,OAAQ,CACN,QAAS,QAAS,QAClB,QAAS,SAAU,QACnB,QAAS,QAAS,SAEpBC,KAAM,CACJ,OAAQ,OAAQ,OAChB,OAAQ,OAAQ,OAChB,OAAQ,OAAQ,SAIPG,EAAe,CAC1Bf,MAAO,CACL,CAACgB,KAAM,UAAWC,KAAM,UAAWC,aAAc,qBACjD,CAACF,KAAM,eAAgBG,IAAK,EAAGC,IAAK,GAAIH,KAAM,QAASC,aAAc,GACrE,CAACF,KAAM,cAAeG,IAAK,EAAGC,IAAK,GAAIH,KAAM,QAASC,aAAc,GACpE,CAACF,KAAM,YAAaG,IAAK,EAAGC,IAAK,EAAGH,KAAM,QAASC,aAAc,IAEnEjB,MAAO,CACL,CAACe,KAAM,UAAWC,KAAM,UAAWC,aAAc,oBACjD,CAACF,KAAM,QAASG,IAAK,EAAGC,IAAK,EAAGH,KAAM,SAGtC,CAACD,KAAM,eAAgBG,IAAK,EAAGC,IAAK,EAAGH,KAAM,QAASI,UAAU,EAAMH,aAAc,IAEtFhB,KAAM,CACJ,CAACc,KAAM,UAAWC,KAAM,UAAWC,aAAc,mBACjD,CAACF,KAAM,YAAaG,IAAK,GAAIC,IAAK,GAAIH,KAAM,SAC5C,CAACD,KAAM,SAAUG,IAAK,EAAGC,IAAK,GAAIH,KAAM,SACxC,CAACD,KAAM,aAAcG,IAAK,EAAGC,IAAK,EAAGH,KAAM,UAE7Cd,KAAM,CACJ,CAACa,KAAM,UAAWC,KAAM,UAAWC,aAAc,sBACjD,CAACF,KAAM,YAAaG,IAAK,EAAGC,IAAK,EAAGH,KAAM,SAC1C,CAACD,KAAM,aAAcC,KAAM,QAASC,aAAc,GAClD,CAACF,KAAM,uBAAwBC,KAAM,QAASC,aAAc,IAE9Dd,MAAO,CACL,CAACY,KAAM,UAAWC,KAAM,UAAWC,aAAc,mBACjD,CAACF,KAAM,cAAeG,IAAK,EAAGC,IAAK,GAAIH,KAAM,SAC7C,CAACD,KAAM,eAAgBG,IAAK,EAAGC,IAAK,GAAIH,KAAM,SAC9C,CAACD,KAAM,cAAeC,KAAM,QAASC,aAAc,IAErDX,MAAO,CACL,CAACS,KAAM,UAAWC,KAAM,UAAWC,aAAc,mBACjD,CAACF,KAAM,SAAUG,IAAK,EAAGC,IAAK,EAAGH,KAAM,UAEzCL,KAAM,CACJ,CAACI,KAAM,UAAWC,KAAM,UAAWC,aAAc,mBACjD,CAACF,KAAM,SAAUG,IAAK,EAAGC,IAAK,EAAGH,KAAM,UAEzCZ,KAAM,CACJ,CAACW,KAAM,UAAWC,KAAM,UAAWC,aAAc,sBACjD,CAACF,KAAM,YAAaG,IAAK,EAAGC,IAAK,GAAIH,KAAM,QAASK,KAAM,GAC1D,CAACN,KAAM,YAAaG,IAAK,EAAGC,IAAK,EAAGH,KAAM,QAASC,aAAc,IAEnEZ,MAAO,CACL,CAACU,KAAM,UAAWC,KAAM,UAAWC,aAAc,qBACjD,CAACF,KAAM,YAAaG,IAAK,EAAGC,IAAK,EAAGH,KAAM,SAC1C,CAACD,KAAM,aAAcC,KAAM,QAASC,aAAc,GAClD,CAACF,KAAM,gBAAiBC,KAAM,QAASC,aAAc,GACrD,CAACF,KAAM,gBAAiBG,IAAK,EAAGC,IAAK,EAAGH,KAAM,SAC9C,CAACD,KAAM,eAAgBG,IAAK,EAAGC,IAAK,EAAGH,KAAM,QAASC,aAAc,IAEtEV,KAAM,CACJ,CAACQ,KAAM,UAAWC,KAAM,UAAWC,aAAc,sBACjD,CAACF,KAAM,YAAaG,IAAK,GAAIC,IAAK,GAAIH,KAAM,SAC5C,CAACD,KAAM,SAAUG,IAAK,EAAGC,IAAK,GAAIH,KAAM,SACxC,CAACD,KAAM,aAAcG,IAAK,EAAGC,IAAK,GAAIH,KAAM,UAE9CR,OAAQ,CACN,CAACO,KAAM,UAAWC,KAAM,UAAWC,aAAc,mBACjD,CAACF,KAAM,cAAeG,IAAK,EAAGC,IAAK,EAAGH,KAAM,QAASK,KAAM,EAAGJ,aAAc,GAC5E,CAACF,KAAM,eAAgBG,IAAK,EAAGC,IAAK,EAAGH,KAAM,QAASC,aAAc,GACpE,CAACF,KAAM,cAAeC,KAAM,QAASC,aAAc,GACnD,CAACF,KAAM,kBAAmBC,KAAM,QAASC,aAAc,IAEzDR,OAAQ,CACN,CAACM,KAAM,UAAWC,KAAM,UAAWC,aAAc,oBACjD,CAACF,KAAM,aAAcG,IAAK,EAAGC,IAAK,EAAGH,KAAM,QAASK,KAAM,EAAGJ,aAAc,GAC3E,CAACF,KAAM,eAAgBG,IAAK,EAAGC,IAAK,EAAGH,KAAM,QAASC,aAAc,GACpE,CAACF,KAAM,aAAcC,KAAM,QAASC,aAAc,GAClD,CAACF,KAAM,kBAAmBC,KAAM,QAASC,aAAc,IAEzDP,OAAQ,CACN,CAACK,KAAM,UAAWC,KAAM,UAAWC,aAAc,mBACjD,CAACF,KAAM,aAAcG,IAAK,EAAGC,IAAK,EAAGH,KAAM,QAASK,KAAM,EAAGJ,aAAc,GAC3E,CAACF,KAAM,cAAeG,IAAK,EAAGC,IAAK,EAAGH,KAAM,SAC5C,CAACD,KAAM,eAAgBG,IAAK,EAAGC,IAAK,EAAGH,KAAM,QAASC,aAAc,GACpE,CAACF,KAAM,aAAcC,KAAM,QAASC,aAAc,GAClD,CAACF,KAAM,kBAAmBC,KAAM,QAASC,aAAc,KAM9CK,EAAmB,CAC9B,QAAS,QAAS,SAAU,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,OAAQ,OAAQ,OAClG,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,OAAQ,SAAU,OACnG,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,OAAQ,OAAQ,OACjG,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QACnG,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QACnG,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QACnG,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QACnG,OAAS,OAAS,OAAS,OAAU,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QACpG,QAAS,QAAS,QAAS,OAAS,OAAQ,QAAS,QAAS,QAAS,QAAS,QAAS,OAAQ,OACjG,QAAS,QAAS,QAAS,OAAS,OAAQ,OAAQ,QAAS,QAAS,QAAS,QAAS,OAAQ,OAChG,SAAU,SAAU,SAAU,OAAS,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAC/F,QAAS,QAAS,QAAS,OAAS,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,S,0NC1MzEC,GANL,IAAIC,YAAY,Q,kDAQ9B,WAAYC,GAAQ,IAAD,8BACjB,cAAMA,IACDC,MAAQ,GAFI,E,iDAKnB,SAAcC,EAAMZ,GAElB,IAAIa,EAAIC,SAASC,cAAc,KAC/BF,EAAEG,KAAOJ,EACTC,EAAEI,SAAWjB,EACba,EAAEK,U,gEAGJ,4BAAAL,EAAA,sEACoBM,IAAeC,gBAAgBC,KAAKX,MAAMY,YAD9D,OACQC,EADR,OAEEF,KAAKG,cAAcD,EAAK,eAF1B,gD,sHAKA,WAAkBE,GAAlB,iBAAAZ,EAAA,sEACoBM,IAAeO,yBAAyBL,KAAKX,MAAMY,WAAYD,KAAKX,MAAMiB,UAAWF,GADzG,OACQF,EADR,OAEQK,EAAU,wCAA0CC,EAAOC,KAAKP,GAAKQ,SAAS,UACpFV,KAAKG,cAAcI,EAAS,2BAH9B,gD,2HAMA,8BAAAf,EAAA,sDACMD,EAAO,IAAIoB,WAAJ,sBACNC,IAAe,qBADT,YAENA,IAAe,oBAFT,YAGNA,IAAe,sBAHT,YAINA,IAAe,yBAGdL,EAAU,wCAA0CC,EAAOC,KAAKlB,GAAMmB,SAAS,UACrFV,KAAKG,cAAcI,EAAS,2BAT9B,gD,0EAYA,WAAU,IAAD,OACP,OAAO,+BACL,eAAC,IAAD,WACE,cAAC,IAAD,CAAUM,OAAK,EAACC,KAAK,UAArB,sBACA,eAAC,IAAD,WACE,cAAC,IAAD,CAAYC,MAAM,4CAA4CC,QAAS,kBAAM,EAAKC,eAAlF,wCACA,cAAC,IAAD,CAAYF,MAAM,sFAAsFC,QAAS,kBAAM,EAAKE,aAAY,IAAxI,kDACA,cAAC,IAAD,CAAYH,MAAM,uGAAuGC,QAAS,kBAAM,EAAKE,aAAY,IAAzJ,qDACA,cAAC,IAAD,CAAYH,MAAM,wDAAwDC,QAAS,kBAAM,EAAKG,mBAA9F,wD,GA9CoCC,IAAMC,c,uHChBpD,wIAAO,IAAMC,EAAoB,CAC7B,UACA,kBACA,mBACA,oBACA,sBAGSC,EAAc,CAGvB,QAAW,CAAC,IAAY,WAAY,WAAY,YAChD,mBAAoB,CAAC,IAAY,MAAY,WAAY,YACzD,kBAAmB,CAAC,IAAY,WAAY,WAAY,YACxD,oBAAqB,CAAC,IAAY,UAAY,UAAY,YAC1D,qBAAsB,CAAC,IAAY,WAAY,WAAY,aAIlDX,EAAiB,CAC1B,QAAW,CAAC,GAAM,EAAM,GAAM,IAC9B,mBAAoB,CAAC,GAAM,EAAM,GAAM,IACvC,kBAAmB,CAAC,GAAM,EAAM,GAAM,IACtC,oBAAqB,CAAC,GAAM,EAAM,GAAM,IACxC,qBAAsB,CAAC,GAAM,EAAM,GAAM,KAGhCY,EAAa,SAACC,GACvB,MAAwB,kBAAbA,EACAF,EAAYE,GAEZF,EAAYD,EAAkBG,M,6YCzBxBC,E,4JAEnB,WACE,OAAO,qBAAKC,UAAU,wBAAwBC,MAAO,CAACC,gBAAiB,IAAM7B,KAAKX,MAAMyC,a,GAH3CV,IAAMC,WCElCU,G,mKACnB,WACE,OAAO,qBAAKJ,UAAU,kBAAf,SACJ3B,KAAKX,MAAM2C,QAAQC,KAAI,SAAAzC,GAAC,OAAI,cAAC,EAAD,CAAuCsC,MAAOtC,EAAEkB,SAAS,IAAIwB,SAAS,EAAG,MAA/C,QAAU1C,Y,GAH3B4B,IAAMC,YCY7Bc,E,kDAKnB,WAAY9C,GAAQ,IAAD,8BACjB,cAAMA,IALR+C,QAAU,KAIS,EAHnB9C,MAAQ,KAGW,EAFnB+C,WAAa,KAEM,EADnBC,gBAAkB,aAGhB,EAAKhD,MAAQD,EAAMC,MACnB,EAAKiD,gBAAgBlD,GAHJ,E,oEASnB,SAAiCmD,GAC/BxC,KAAKuC,gBAAgBC,GACrBxC,KAAKyC,SAASD,EAAUlD,S,6BAG1B,SAAgBD,GACdW,KAAKoC,QAAU/C,EAAM+C,QACrBpC,KAAKqC,WAAahD,EAAMgD,WACxBrC,KAAKsC,gBAAkB,SAAC9C,EAAGkD,EAAGC,GAC1BtD,EAAMiD,gBAAgB9C,EAAGkD,EAAGC,M,oBAIlC,WAAU,IAAD,OACDP,EAAUpC,KAAKoC,QAErB,GAAIA,EAAQpD,UAAwB,OAAZoD,EAAoB,OAAO,wBAAW,oBAAsBA,EAAQxD,KAAOwD,EAAQzD,MAC3G,OAAQyD,EAAQxD,MACd,IAAK,QAEH,OAAO,sBAAK+C,UAAU,cAAf,UACH,cAAC,IAAD,CACE7C,IAAKsD,EAAQtD,IACbC,IAAKqD,EAAQrD,IACbE,KAAMmD,EAAQnD,MAAQ,EACtB2D,MAAOR,EAAQzD,KACfkE,MAAO7C,KAAKV,MAAMgB,UAAUN,KAAKqC,YAAYD,EAAQzD,MACrDmE,WAAY,SAAAC,GAAC,OAAI,EAAKT,gBAAgB,EAAKD,WAAYD,EAAQzD,KAAMoE,EAAEC,OAAOH,SANlE7C,KAAKqC,WAAaD,EAAQzD,MAQxC,sBAAKgD,UAAU,cAAf,UACE,uBAAOA,UAAU,OAAjB,SAAyBS,EAAQtD,MACjC,wBAAO6C,UAAU,MAAjB,sBAAiC3B,KAAKV,MAAMgB,UAAUN,KAAKqC,YAAYD,EAAQzD,SAC/E,uBAAOgD,UAAU,QAAjB,SAA0BS,EAAQrD,WAZC,SAAWqD,EAAQxD,KAAOwD,EAAQzD,MAe7E,IAAK,QACH,OAAO,qBAAKgD,UAAU,cAAf,SACL,cAAC,IAAD,CAAciB,MAAOR,EAAQzD,KAA7B,SACG,CAAC,EAAG,EAAG,EAAG,GAAGsD,KAAI,SAAAgB,GAChB,OAAO,eAAC,IAAD,CACHJ,MAAOI,EACPC,QAAS,EAAK5D,MAAMgB,UAAU,EAAK+B,YAAYD,EAAQzD,QAAUsE,EAEjEH,WAAY,SAAAC,GAAC,OAAIA,EAAEC,OAAOE,QAAU,EAAKZ,gBAAgB,EAAKD,WAAYD,EAAQzD,KAAMsE,GAAK,MAJ1F,mBAMIA,EAAE,EACT,cAAC,EAAD,CAAqBnB,MAAON,YAAW,EAAKlC,MAAMgB,UAAU,EAAK+B,YAA1B,SAAkDY,GAAGvC,SAAS,IAAIwB,SAAS,EAAG,SAJhH,gBAAkBE,EAAQxD,KAAOwD,EAAQzD,KAAO,IAAMsE,SAN5B,WAAab,EAAQxD,KAAOwD,EAAQzD,MAe/E,IAAK,UACH,OAAO,qBAAKgD,UAAU,cAAf,SACL,cAAC,IAAD,CACEiB,MAAM,gBACNC,MAAO7C,KAAKV,MAAMgB,UAAUN,KAAKqC,YAAYD,EAAQzD,MACrDmE,WAAY,SAAAC,GAAC,OAAI,EAAKT,gBAAgB,EAAKD,WAAYD,EAAQzD,KAAMoE,EAAEC,OAAOH,QAHhF,SAIKvB,IAAkBW,KAAI,SAAAzC,GAAC,OAAI,eAAC,IAAD,CAAoBqD,MAAOrD,EAA3B,UAA+BA,EAA/B,IAAkC,cAAC,EAAD,CAAgBwC,QAASR,YAAWhC,OAArDA,SALV,WAAa4C,EAAQxD,KAAOwD,EAAQzD,MAQ/E,QAEE,OADAwE,QAAQC,MAAR,oCAA2ChB,EAAQxD,KAAnD,YAAmEwD,GAC5D,8B,GA5E0BhB,IAAMC,W,iBCX1BgC,E,4JACnB,WAAU,IAAD,OACDC,EAAS7E,IAAiBuB,KAAKX,MAAMkE,QAAQtB,KAAI,SAAAuB,GAAE,OAAI,EAAKnE,MAAMY,WAAWuD,MACnF,OAAO,qBAAK7B,UAAU,0BAAf,SACJ2B,EAAOrB,KAAI,SAACwB,EAAKC,GAAN,OAAY,qBAAKC,IAAI,GAAGF,IAAKA,GAAU,WAAaC,Y,GAJ9BtC,IAAMC,W,SCGzBlC,G,yDAEnB,WAAYE,GAAQ,IAAD,8BACjB,cAAMA,IACDuE,SAAWxC,IAAMyC,YACtB,EAAKvE,MAAQ,CAACwE,SAAU,MAHP,E,qFAMnB,gCAAAtE,EAAA,sEACoBM,IAAeiE,mBAAmB/D,KAAKX,MAAMY,YADjE,OACQC,EADR,OAEEF,KAAKyC,SAAS,CAACqB,SAAU5D,IAEzB,UAAAF,KAAK4D,gBAAL,mBAAeI,eAAf,SAAwBC,OAJ1B,gD,0EAQA,WAAU,IAAD,OACP,OAAO,iCACL,cAAC,IAAD,CAAWC,QAAQ,8CAAnB,SACE,cAAC,IAAD,CAAUlD,QAAS,kBAAM,EAAKmD,cAA9B,8BAEF,cAAC,IAAD,CAAUvB,MAAM,cAAcwB,IAAKpE,KAAK4D,SAAUjC,UAAU,qBAA5D,SACE,qBAAKgC,IAAI,cAAcF,IAAKzD,KAAKV,MAAMwE,oB,GAtBD1C,IAAMC,Y,SCiOrCgD,G,yDAlNb,WAAYhF,GAAQ,IAAD,uBACjB,cAAMA,IACDC,MAAQ,CACXgF,SAAU7G,IACV6C,UAAW,GAEX0B,QAASR,YAAW,GAEpB+C,eAAgB,iFAChBC,gBAAiB,IAInBhH,IAAqBiH,SAAQ,SAAAC,GAI3B,EAAKpF,MAAMgB,UAAUoE,GAAK,GAE1BhG,IAAagG,GAAGD,SAAQ,SAAAE,GACtB,QAAyBC,IAArBD,EAAI9F,aAEN,EAAKS,MAAMgB,UAAUoE,GAAGC,EAAIhG,MAAQgG,EAAI9F,kBACnC,QAAgB+F,IAAZD,EAAI7F,UAAiC8F,IAAZD,EAAI5F,IAAmB,CACzD,IAAI8F,EAAMC,KAAKC,MAAMD,KAAKE,UAAYL,EAAI5F,IAAM4F,EAAI7F,IAAK,IAAM6F,EAAI7F,IAG/D6F,EAAI1F,OACN4F,GAAQA,EAAMF,EAAI1F,MAGpB,EAAKK,MAAMgB,UAAUoE,GAAGC,EAAIhG,MAAQkG,MAGxC,EAAKvF,MAAMkF,gBAAgBE,GAAK,QAKlC,IACE,IAAMO,EAAeC,aAAaC,QAAQ,iCACrB,OAAjBF,IACF,EAAK3F,MAAMgF,SAAWW,GAExB,MAAOlC,GACPI,QAAQiC,KAAK,oEAAqErC,GA7CnE,S,4FAkDnB,4BAAAvD,EAAA,sDACWkE,EAAI,EADf,YACkBA,EAAIlG,IAAqB6H,QAD3C,gCAEUrF,KAAKsF,kBAAkB9H,IAAqBkG,IAAI,GAF1D,OACmDA,IADnD,sBAKE1D,KAAKuF,cALP,gD,+EASA,WAAe,IAAD,OACRC,EAAW,CAAClF,UAAU,eAAKN,KAAKV,MAAMgB,YAC1C9C,IAAqBiH,SAAQ,SAAAC,GAC3Bc,EAASlF,UAAUoE,GAAnB,eAA4B,EAAKpF,MAAMgB,UAAUoE,IACjDhG,IAAagG,GAAGD,SAAQ,SAAAE,GACtB,IAAKA,EAAI3F,eACS4F,IAAZD,EAAI7F,UAAiC8F,IAAZD,EAAI5F,IAAmB,CAClD,IAAI8F,EAAMC,KAAKC,MAAMD,KAAKE,UAAYL,EAAI5F,IAAM4F,EAAI7F,IAAM,IAAM6F,EAAI7F,IAGhE6F,EAAI1F,OACN4F,GAAQA,EAAMF,EAAI1F,MAGpBuG,EAASlF,UAAUoE,GAAGC,EAAIhG,MAAQkG,SAK1C7E,KAAKyC,SAAS+C,EAAUxF,KAAKuF,e,sEAG/B,WAAwBjB,GAAxB,+BAAA9E,EAAA,yDAAkCiG,EAAlC,gCACMzD,EAAUhC,KAAKV,MAAM0C,QACrBhC,KAAKV,MAAMgB,UAAUgE,GAAUoB,UACjC1D,EAAUR,YAAWxB,KAAKV,MAAMgB,UAAUgE,GAAUoB,UAET,OAAzC1F,KAAKV,MAAMkF,gBAAgBF,KAAsBmB,EALvD,gCAMoB3F,IAAe6F,cAAcrB,EAAUtE,KAAKV,MAAMgB,UAAUgE,GAAWtC,GAN3F,cAMQ4D,EANR,OAOI5F,KAAKyC,SAAS,CAAC+B,gBAAgB,2BAC1BxE,KAAKV,MAAMkF,iBADc,kBAE3BF,EAAWsB,MATlB,kBAWWA,GAXX,gCAaS5F,KAAKV,MAAMkF,gBAAgBF,IAbpC,iD,+HAkBA,wCAAA9E,EAAA,6DAA0BiG,EAA1B,yCACezF,KAAKsF,kBAAkBtF,KAAKV,MAAMgF,SAAUmB,GAD3D,wF,sHAKA,wCAAAjG,EAAA,6DAAkBiG,IAAlB,sCACEzF,KADF,SACuCA,KAAK6F,oBAAoBJ,GADhE,yBACiBlB,eADjB,WACO9B,SADP,gE,kFAKA,SAAeqD,GAAQ,IAAD,OACpB9F,KAAKyC,SAAS,CAAC6B,SAAUwB,EAAM9C,OAAOH,QAAQ,kBAAM,EAAK0C,aAAY,MACrEL,aAAaa,QAAQ,gCAAiCD,EAAM9C,OAAOH,S,6BAIrE,SAAgBmD,EAAUrH,EAAMkE,GAE1B7C,KAAKV,MAAMgB,UAAU0F,GAAUrH,KAAUkE,GAK7C7C,KAAKyC,SAAS,CACZnC,UAAU,2BACLN,KAAKV,MAAMgB,WADP,kBAEN0F,EAFM,2BAGFhG,KAAKV,MAAMgB,UAAU0F,IAHnB,kBAIJrH,EAAOkE,OAGX7C,KAAKuF,e,oBAGV,WAAU,IAAD,OACP,OACE,sBAAK5D,UAAU,MAAf,UACE,wBAAQA,UAAU,aAAlB,SACE,uDAEF,oCAEE,sBAAKA,UAAU,cAAf,UACE,cAAC,EAAD,CAAkB1B,WAAYD,KAAKV,MAAMkF,kBACzC,cAAC,IAAD,CAAkBvE,WAAYD,KAAKV,MAAMkF,gBAAiBlE,UAAWN,KAAKV,MAAMgB,YAEhF,cAAC,IAAD,CAAW4D,QAAQ,wCAAnB,SACE,cAAC,IAAD,CAAUlD,QAAS,kBAAM,EAAKiF,eAA9B,kCAEF,cAAC,IAAD,CAAW/B,QAAQ,kDAAnB,SACE,cAAC,IAAD,CAAUlD,QAAS,kBAAM,EAAKuE,aAAY,IAA1C,6BAIJ,sBAAK5D,UAAU,eAAf,UACE,sBAAKA,UAAU,OAAf,UACE,8CAEA,wCACA,qBAAKA,UAAU,eAAegC,IAAI,eAAeF,IAAKzD,KAAKV,MAAMiF,iBACjE,uCACA,cAAC,EAAD,CAAYhB,OAAQvD,KAAKV,MAAMgF,SAAUrE,WAAYD,KAAKV,MAAMkF,kBAChE,qBAAK7C,UAAU,SAAf,SACE,cAAC,IAAD,CAAUhC,KAAMK,KAAKV,MAAMiF,eAAgB3E,SAAUI,KAAKV,MAAMgF,SAAW,OAA3E,2BAGJ,sBAAK3C,UAAU,QAAf,UACE,oDACA,qBAAKA,UAAU,cAAf,SACE,cAAC,IAAD,CAAUiB,MAAM,YAAYC,MAAO7C,KAAKV,MAAMgF,SAAUxB,WAAY,SAAAC,GAAC,OAAI,EAAKmD,eAAenD,IAAIpB,UAAU,mBAA3G,SACGnE,IAAqByE,KAAI,SAAAzC,GAAC,OAAI,eAAC,IAAD,CAAoBqD,MAAOrD,EAA3B,UAA+BhB,IAAWgB,GAA1C,IAA8C,qBAAKmE,IAAI,GAAG7C,KAAK,SAAS2C,IAAK,EAAKnE,MAAMkF,gBAAgBhF,KAAxG,MAAiBA,UAInDd,IAAasB,KAAKV,MAAMgF,UAAUrC,KAAI,SAAAG,GAAO,OAC5C,cAAC,EAAD,CAEEA,QAASA,EACT9C,MAAO,EAAKA,MACZ+C,WAAY,EAAK/C,MAAMgF,SACvBhC,gBAAiB,SAAC9C,EAAGkD,EAAGC,GAAP,OAAa,EAAKL,gBAAgB9C,EAAGkD,EAAGC,KAJpD,EAAKrD,MAAMgF,SAAWlC,EAAQzD,kBAU7C,mCACE,qDACsB,mBAAGgB,KAAK,8CAA8CqD,OAAO,SAA7D,4CADtB,mBAEgB,mBAAGrD,KAAK,0BAA0BqD,OAAO,SAAzC,sBAFhB,OAKA,kIAEE,mBAAGrD,KAAK,qDAAqDqD,OAAO,SAApE,oBAFF,WAE6F,IAC3F,mBAAGrD,KAAK,4DAA4DqD,OAAO,SAA3E,8BAHF,OAKA,gIACkG,IAChG,mBAAGrD,KAAK,kCAAkCqD,OAAO,SAAjD,6BAEF,2EAA6C,mBAAGrD,KAAK,yBAAyBqD,OAAO,SAAxC,4BAA7C,OACA,cAAC,IAAD,CAAWkB,QAAQ,sBAAnB,SACE,oBAAGvC,UAAU,UAAUhC,KAAK,4EAA4EqD,OAAO,SAA/G,qBAAiImD,uB,GA7M3H/E,IAAMC,YCZT+E,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,8BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCDdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFtH,SAASuH,eAAe,SAM1BZ,K,kKCVA,SAASa,EAAQzH,EAAGkD,GAClB,OAASlD,EAAIkD,EAAMA,GAAKA,EAI1B,SAASwE,EAAqBC,GAI5B,MAAO,CAACC,EAHAtC,KAAKC,MAAMD,KAAKE,SAAWmC,EAAME,OAAOC,OAGrCC,EAFHzC,KAAKC,MAAMD,KAAKE,SAAWmC,EAAME,OAAOG,S,IAa7B1H,E,kGAGnB,SAAqBwE,EAAUmD,EAASzF,GAEtC,OAAO,IAAI0F,SAAQ,SAACC,EAASC,GAC3B,IAAIC,IAAKvK,IAAaC,IAAcyE,EAAQtE,IAAuB4G,IAAnE,uCAA+E,WAAOwD,EAAKX,GAAZ,SAAA3H,EAAA,sDACzEsI,GAAOF,EAAOE,GAD2D,KAIrExD,EAJqE,OAKtE,UALsE,OAQtE,UARsE,OAWtE,UAXsE,QActE,SAdsE,MAetE,UAfsE,QAkBtE,SAlBsE,QAqBtE,UArBsE,QAwBtE,SAxBsE,QA2BtE,SA3BsE,QA8BtE,SA9BsE,QAiCtE,WAjCsE,QAoCtE,WApCsE,QAuCtE,WAvCsE,wCAMrExE,EAAeiI,UAAUZ,EAAOM,EAASzF,GAN4B,0DASnElC,EAAekI,UAAUb,EAAOM,EAASzF,GAT0B,4DAYnElC,EAAemI,UAAUd,EAAOM,EAASzF,GAZ0B,6DAgBnElC,EAAeoI,UAAUf,EAAOM,EAASzF,GAhB0B,6DAmBnElC,EAAeqI,SAAShB,EAAOM,EAASzF,GAnB2B,6DAsBnElC,EAAesI,UAAUjB,EAAOM,EAASzF,GAtB0B,6DAyBnElC,EAAeuI,SAASlB,EAAOM,EAASzF,GAzB2B,6DA4BnElC,EAAewI,SAASnB,EAAOM,EAASzF,GA5B2B,6DA+BnElC,EAAeyI,SAASpB,EAAOM,EAASzF,GA/B2B,6DAkCnElC,EAAe0I,WAAWrB,EAAOM,EAASzF,GAlCyB,6DAqCnElC,EAAe2I,WAAWtB,EAAOM,EAASzF,GArCyB,6DAwCnElC,EAAe4I,WAAWvB,EAAOM,EAASzF,GAxCyB,4CA2CzEmB,QAAQwF,KAAK,iCAAkCrE,EAAU,oBA3CgB,QA8C7E6C,EAAMyB,eAAe,aAAarC,KAAKoB,EAASC,GA9C6B,4CAA/E,8D,uBAqDJ,SAAiBT,EAAOM,EAASzF,GAC/B,IAAK,IAAI0B,EAAI,EAAGA,EAAI+D,EAAQ,gBAAiB/D,IAAK,CAChD,MAAewD,EAAqBC,GAA7BC,EAAP,EAAOA,EAAGG,EAAV,EAAUA,EACVJ,EAAM0B,cAAc7G,EAAQ,GAAIoF,EAAGG,GAErC,IAAK,IAAI7D,EAAI,EAAGA,EAAI+D,EAAQ,eAAgB/D,IAAK,CAC/C,MAAewD,EAAqBC,GAA7BC,EAAP,EAAOA,EAAGG,EAAV,EAAUA,EACVJ,EAAM0B,cAAc7G,EAAQ,GAAIoF,EAAGG,GACnCJ,EAAM0B,cAAc7G,EAAQ,GAAIoF,EAAS,IAANG,EAAWJ,EAAME,OAAOG,OAAS,EAAKD,EAAE,GAG7E,IAAK,IAAI7D,EAAI,EAAGA,EAAI+D,EAAO,UAAe/D,IAAK,CAC7C,MAAewD,EAAqBC,GAA7BC,EAAP,EAAOA,EAAGG,EAAV,EAAUA,EAEVJ,EAAM0B,cAAc7G,EAAQ,GAAIoF,EAAI,EAAIA,EAAE,EAAKD,EAAME,OAAOC,MAAQ,EAAIC,GACxEJ,EAAM0B,cAAc7G,EAAQ,GAAIoF,EAAKD,EAAME,OAAOC,MAAQ,EAAKF,EAAE,EAAI,EAAGG,GACxEJ,EAAM0B,cAAc7G,EAAQ,GAAIoF,EAAGG,EAAI,EAAIA,EAAE,EAAKJ,EAAME,OAAOG,OAAS,M,uBAI5E,SAAiBL,EAAOM,EAASzF,GAG/B,IAHyC,IAAD,WAG/B0B,GACP,MAAiCwD,EAAqBC,GAA5C2B,EAAV,EAAO1B,EAAe2B,EAAtB,EAAmBxB,EACbyB,EAASlE,KAAKC,MAAsB,EAAhBD,KAAKE,UAAgB,EAE/CmC,EAAM8B,KAAK,EAAG,EAAG9B,EAAME,OAAOC,MAAOH,EAAME,OAAOG,QAAQ,SAACJ,EAAGG,EAAG2B,GAC/D,IAAMC,EAAKL,EAAU1B,EACfgC,EAAKL,EAAUxB,EACjB4B,EAAGA,EAAKC,EAAGA,GAAOJ,EAAOA,GAC3B7B,EAAM0B,cAAc7G,EAAQ,GAAIoF,EAAGG,OARhC7D,EAAI,EAAGA,EAAI+D,EAAQ,gBAAiB/D,IAAM,IAcnD,IAAK,IAAIA,EAAI,EAAGA,EAAI+D,EAAO,MAAW/D,IAAK,CAEzC,MAAiCwD,EAAqBC,GAA5C2B,EAAV,EAAO1B,EAAe2B,EAAtB,EAAmBxB,EAEb8B,EAA0C,IAAlCvE,KAAKC,MAAsB,EAAhBD,KAAKE,UAAsB,GAAK,EACnDsE,EAA0C,IAAlCxE,KAAKC,MAAsB,EAAhBD,KAAKE,UAAsB,GAAK,EACrDoC,EAAI0B,EAASvB,EAAIwB,EAOrB,IALA5B,EAAM0B,cAAc7G,EAAQ,GAAIoF,EAAGG,GACnCH,EAAIH,EAAQG,EAAIiC,EAAOlC,EAAME,OAAOC,OACpCC,EAAIN,EAAQM,EAAI+B,EAAOnC,EAAME,OAAOG,QAG7BJ,IAAM0B,GAAWvB,IAAMwB,GAC5B5B,EAAM0B,cAAc7G,EAAQ,GAAIoF,EAAGG,GAG/BzC,KAAKE,SAAW,KAElBoC,EAAIH,EAAQG,EAAIiC,EAAOlC,EAAME,OAAOC,QAElCxC,KAAKE,SAAW,KAClBuC,EAAIN,EAAQM,EAAI+B,EAAOnC,EAAME,OAAOG,SAKxCL,EAAM0B,cAAc7G,EAAQ,GAAIoF,EAAGG,M,uBAKvC,SAAiBJ,EAAOM,EAASzF,GAI/B,IAHA,IAAMuH,EAAY,GACZC,EAAY,GAET9F,EAAI,EAAGA,EAAIyD,EAAME,OAAOC,MAAO5D,IACW,IAA7CuD,EAAQvD,EAAE,EAAG+D,EAAQ,eAAiB,GACxC8B,EAAUE,KAAK/F,GACkF,IAAxFuD,EAAQvD,EAAI,EAAIoB,KAAKC,MAAM0C,EAAQ,eAAiB,GAAIA,EAAQ,eAAiB,IAC1F+B,EAAUC,KAAK/F,GAInB,IAAIgG,EAAS,EACbvC,EAAM8B,KAAK,EAAG,EAAG9B,EAAME,OAAOC,MAAOH,EAAME,OAAOG,QAAQ,SAACJ,EAAGG,EAAG2B,GAE/D/B,EAAM0B,cAAc7G,EAAQyF,EAAQ,gBAAiBL,EAAGG,GAGpDA,GAAKE,EAAQ,gBAAkB,KAAO,IACxCN,EAAM0B,cAAc7G,EAAQ,GAAIoF,EAAGG,GAGzB,IAANH,KAAasC,GAIfA,EAAS,IAAM,GACa,IAA1BH,EAAUI,QAAQvC,IACpBD,EAAM0B,cAAc7G,EAAQ,GAAIoF,EAAGG,IAGP,IAA1BiC,EAAUG,QAAQvC,IACpBD,EAAM0B,cAAc7G,EAAQ,GAAIoF,EAAGG,Q,uBAO3C,SAAiBJ,EAAOM,EAASzF,GAC/BmF,EAAM8B,KAAK,EAAG,EAAG9B,EAAME,OAAOC,MAAOH,EAAME,OAAOG,QAAQ,SAACJ,EAAGG,GAC5D,IAAMqC,EAAsC,GAA1B,GAAKnC,EAAO,QAG9BN,EAAM0B,cAAczB,EAAKD,EAAME,OAAOG,OAASD,EAAI,EAAKvF,EAAQ,GAAKA,EAAQ,GAAIoF,EAAGG,GAKhFH,IAAMG,EACRJ,EAAM0B,cAAc7G,EAAQ,GAAIoF,EAAGG,GAC1BH,IAAOD,EAAME,OAAOG,OAASD,EAAI,GAC1CJ,EAAM0B,cAAc7G,EAAQ,GAAIoF,EAAGG,GAIrC,IAAMsC,EAAM1C,EAAME,OAAOG,OAAS,EAAMoC,EAAW,EAG/CxC,EAAIyC,GAAKzC,EAAKyC,EAAID,EAAW,GAC3BrC,EAAIsC,GAAKtC,EAAKsC,EAAID,EAAW,GAC/BzC,EAAM0B,cAAc7G,EAAQ,GAAIoF,EAAGG,Q,sBAM3C,SAAgBJ,EAAOM,EAASzF,GAC9B,IAAM8H,EAAchF,KAAKC,MAAOoC,EAAME,OAAOC,MAAQ,EAAMG,EAAQ,aAAe,GAE5EsC,EAAYtC,EAAQ,aAE1BN,EAAM8B,KAAK,EAAG,EAAG9B,EAAME,OAAOC,MAAOH,EAAME,OAAOG,QAAQ,SAACJ,EAAGG,GAI5D,GACGH,EAAI0C,GAAe1C,EAAKD,EAAME,OAAOC,MAAQ,EAAIwC,GACjDvC,EAAIuC,GAAevC,EAAKJ,EAAME,OAAOG,OAAS,EAAIsC,EACnD,CAGA,IACG1C,GAAM0C,EAAcC,GAAc3C,EAAI0C,GAAgBvC,EAAIuC,GAAevC,EAAKJ,EAAME,OAAOG,OAAS,EAAIsC,GACxG1C,GAAM0C,EAAcrC,EAAQ,cAAiBL,EAAK0C,EAAcrC,EAAQ,aAAesC,GAAexC,EAAIuC,GAAevC,EAAKJ,EAAME,OAAOG,OAAQ,EAAIsC,GAEvJvC,GAAMuC,EAAcC,GAAcxC,EAAIuC,GAAgB1C,EAAI0C,GAAe1C,EAAKD,EAAME,OAAOC,MAAQ,EAAIwC,GACvGvC,GAAMuC,EAAcrC,EAAQ,cAAiBF,EAAKuC,EAAcrC,EAAQ,aAAesC,GAAe3C,EAAI0C,GAAe1C,EAAKD,EAAME,OAAOC,MAAO,EAAIwC,IAGnJhF,KAAKE,SAAW,IAAQ,OAG9BmC,EAAM0B,cAAc7G,EAAQ,GAAIoF,EAAGG,S,uBAMzC,SAAiBJ,EAAOM,EAASzF,GAO/B,IAJA,IAGIgI,EAAOC,EAAIC,EAHTC,EAAI1C,EAAQ,aACLF,EAAI,GAAKzC,KAAKC,MAAM0C,EAAQ,aAAe,GAG/C/D,EAAI,EAAGA,EAAI,IAAKA,IACvBsG,EAAQtG,EACRuG,EAAKE,EAAIrF,KAAKsF,IAAIJ,EAAQlF,KAAKuF,GAAK,KACpCH,EAAKC,EAAIrF,KAAKwF,IAAIN,EAAQlF,KAAKuF,GAAK,KAEpClD,EAAM0B,cAAc7G,EAAQ,GAAI8C,KAAKyF,MAR7B,EAQuCN,GAAKnF,KAAKyF,MAAMhD,EAAI2C,IAIrE,IAAK,IAAIM,EAAO,EAAGA,EAAOrD,EAAME,OAAOG,OAAQgD,IAI7C,IAFA,IAAIC,GAAU,EAAOC,GAAS,EAAOC,GAAW,EAAOC,EAAa,EAE3DC,EAAO,EAAGA,EAAO1D,EAAME,OAAOC,MAAOuD,IAExC1D,EAAM2D,cAAcD,EAAML,KAAUxI,EAAQ,IAC9C4I,IACKH,EAEMC,IACTC,GAAW,GAFXF,GAAU,IAKRA,GAAWtD,EAAM2D,cAAcD,EAAML,KAAUxI,EAAQ,KACzD0I,GAAS,GAEPA,IAAWC,GAAYC,EAAa,GACtCzD,EAAM0B,cAAc7G,EAAQyF,EAAQ,eAAgBoD,EAAML,IAOlE,IAAK,IAAIO,EArCC,EAqCajG,KAAKC,MAAMoF,EAAE,GAAG,EAAGY,EArChC,EAqC8CZ,EAAE,EAAGY,IAC3D5D,EAAM0B,cAAc7G,EAAQ,GAAI+I,EAASxD,EAAI4C,EAAI,GAC7CY,EAvCI,EAuCUZ,GAChBhD,EAAM0B,cAAc7G,EAAQ,GAAI+I,EAASxD,EAAI4C,GAKjD,IAAIa,EAAe,EAEnB,IAAStH,EAAI,EAAGA,EAAI,OAGdsH,GAAgBvD,EAAQ,kBAHL/D,IAAK,CAQ5B,IAAMuH,EAAKnG,KAAKC,MAAMD,KAAKE,SAAYmC,EAAME,OAAOC,OAClD4D,EAAKpG,KAAKC,MAAMD,KAAKE,SAAWmC,EAAME,OAAOG,QAG3CL,EAAM2D,cAAcG,EAAGC,KAAQlJ,EAAQyF,EAAQ,iBACjDuD,IAEA7D,EAAM0B,cAAc7G,EAAQyF,EAAQ,kBAAmBwD,EAAIC,GAGvDzD,EAAQ,gBAAkB,GAC5B,CAAC,CAACwD,EAAG,EAAGC,GAAK,CAACD,EAAG,EAAEC,GAAK,CAACD,EAAIC,EAAG,GAAI,CAACD,EAAIC,EAAG,IAAIzG,SAAQ,SAAA0G,GACtD,IAAMC,EAAMD,EAAO,GAAIE,EAAMF,EAAO,GAChChE,EAAM2D,cAAcM,EAAKC,KAASrJ,EAAQyF,EAAQ,gBACpDN,EAAM0B,cAAc7G,EAAQyF,EAAQ,kBAAmB2D,EAAKC,U,6DAQxE,WAAsBlE,EAAOM,EAASzF,GAAtC,+GAKwB6F,IAAKyD,KAAKnE,GALlC,OAaE,IARMoE,EALR,OAQQpB,EAAI1C,EAAQ,aAGR,EAAGF,EAAIgE,EAAQlE,OAAOG,QAAUC,EAAQ,aAAe,GAExD/D,EAAI,EAAGA,EAAI,IAAKA,IACvBsG,EAAQtG,EACRuG,EAAKE,EAAIrF,KAAKsF,IAAIJ,EAAQlF,KAAKuF,GAAK,KACpCH,EAAKC,EAAIrF,KAAKwF,IAAIN,EAAQlF,KAAKuF,GAAK,KAEpCkB,EAAQ1C,cAAc7G,EAAQ,GAAI8C,KAAKyF,MAP/B,EAOyCN,GAAKnF,KAAKyF,MAAMhD,EAAI2C,IAIvE,IAASM,EAAO,EAAGA,EAAOe,EAAQlE,OAAOG,OAAQgD,IAE/C,IADIC,GAAU,EAAOC,GAAS,EAAOC,GAAW,EAAOC,EAAa,EAC3DC,EAAO,EAAGA,EAAOU,EAAQlE,OAAOC,MAAOuD,IAC1CU,EAAQT,cAAcD,EAAML,KAAUxI,EAAQ,IAChD4I,IACKH,EAEMC,IACTC,GAAW,GAFXF,GAAU,IAKRA,GAAWc,EAAQT,cAAcD,EAAML,KAAUxI,EAAQ,KAC3D0I,GAAS,GAEPA,IAAWC,GAAYC,EAAa,IACjCC,EAAOL,EAAQL,EAAIrF,KAAKC,MAAMoF,EAAE,KACnCoB,EAAQ1C,cAAc7G,EAAQyF,EAAQ,eAAgBoD,EAAML,GAE5De,EAAQ1C,cAAc7G,EAAQyF,EAAQ,yBAA0BoD,EAAML,KAxClF,gBAiDQrD,EAAMqE,KAAKD,EAAS,GAAI,EAAIzG,KAAKC,MAAOoC,EAAME,OAAOG,OAAS,EAAMC,EAAQ,eAjDpF,2C,wHAoDA,WAAsBN,EAAOM,EAASzF,GAAtC,iFAOE,IALMyJ,EAAahE,EAAO,UAAgB,IACxCiE,EAASjE,EAAO,OAChBkE,EAAYlE,EAAQ,cAGbF,EAAI,EAAGA,EAAIJ,EAAME,OAAOC,MAAOC,IAAK,CAM3C,IAJIH,EAAItC,KAAKwF,IAAKmB,GAAa3G,KAAK8G,IAAIrE,EAAEmE,GAAUvE,EAAME,OAAOC,QAAYxC,KAAKC,MAAMoC,EAAME,OAAOG,OAAS,GAIvGJ,EAAID,EAAME,OAAOC,OAEtBH,EAAM0B,cAAc,WAAYzB,EAAGG,GACnCH,GAAKuE,EAKP,IADIE,EAAY,EACXzE,EAAI,EAAGA,EAAID,EAAME,OAAOC,MAAOF,IACA,aAA9BD,EAAM2D,cAAc1D,EAAGG,KACzBsE,EAAY,GAAIA,EAAY,GAAK,GAEnC1E,EAAM0B,cAAc7G,EAAQ6J,GAAYzE,EAAGG,GAzBjD,2C,wHA8BA,WAAsBJ,EAAOM,EAASzF,GAAtC,iFAKE,IAHMyJ,EAAahE,EAAO,UAAgB,IACxCiE,EAASjE,EAAO,OAChBkE,EAAYlE,EAAQ,cACbF,EAAI,EAAGA,EAAIJ,EAAME,OAAOC,MAAOC,IAAK,CAI3C,IAHIH,EAAItC,KAAKwF,IAAKmB,GAAa3G,KAAK8G,IAAIrE,EAAEmE,GAAUvE,EAAME,OAAOC,QAAYxC,KAAKC,MAAMoC,EAAME,OAAOG,OAAS,GAGvGJ,EAAID,EAAME,OAAOC,OAEtBH,EAAM0B,cAAc,WAAYzB,EAAGG,GACnCH,GAAKuE,EAKP,IADIE,EAAY,EACXzE,EAAI,EAAGA,EAAID,EAAME,OAAOC,MAAOF,IACA,aAA9BD,EAAM2D,cAAc1D,EAAGG,KACzBsE,EAAY,GAAIA,EAAY,GAAK,GAEnC1E,EAAM0B,cAAc7G,EAAQ6J,GAAYzE,EAAGG,GArBjD,2C,0HA0BA,WAAwBJ,EAAOM,EAASzF,GAAxC,iEACEmF,EAAM8B,KAAK,EAAG,EAAG9B,EAAME,OAAOC,MAAOH,EAAME,OAAOG,QAAQ,SAACJ,EAAGG,GAExDH,GAAKK,EAAQ,eAAe,KAAO,GAAKF,EAAIE,EAAQ,iBAAmBF,EAAKJ,EAAME,OAAOC,MAAQG,EAAQ,gBAAkB,EAC7HN,EAAM0B,cAAc7G,EAAQyF,EAAQ,oBAAqBL,EAAGG,GAE5DJ,EAAM0B,cAAc7G,EAAQyF,EAAQ,gBAAiBL,EAAGG,MAN9D,2C,0HAWA,WAAwBJ,EAAOM,EAASzF,GAAxC,iEACEmF,EAAM8B,KAAK,EAAG,EAAG9B,EAAME,OAAOC,MAAOH,EAAME,OAAOG,QAAQ,SAACJ,EAAGG,GAExDA,GAAKE,EAAQ,cAAc,KAAO,GAAKL,EAAIK,EAAQ,iBAAmBL,EAAKD,EAAME,OAAOC,MAAQG,EAAQ,gBAAkB,EAC5HN,EAAM0B,cAAc7G,EAAQyF,EAAQ,oBAAqBL,EAAGG,GAE5DJ,EAAM0B,cAAc7G,EAAQyF,EAAQ,eAAgBL,EAAGG,MAN7D,2C,0HAWA,WAAwBJ,EAAOM,EAASzF,GAAxC,iEAEEmF,EAAM8B,KAAK,EAAG,EAAG9B,EAAME,OAAOC,MAAOH,EAAME,OAAOG,QAAQ,SAACJ,EAAGG,GAE5D,IAAIuE,EAAahH,KAAKC,OAAOqC,EAAE,GAAKK,EAAQ,eAAiBA,EAAQ,eAKnEL,GAAKK,EAAQ,cAAc,KAAO,GAElCF,EAAIE,EAAQ,gBAAmBqE,GAE/BvE,EAAKJ,EAAME,OAAOC,MAAQG,EAAQ,gBAAkB,EAEpDN,EAAM0B,cAAc7G,EAAQyF,EAAQ,oBAAqBL,EAAGG,GAE5DJ,EAAM0B,cAAc7G,EAAQyF,EAAQ,eAAgBL,EAAGG,MAjB7D,2C,+HAwBA,WAA6BwE,GAA7B,wEACEA,EAAUA,EAAQC,OAAOD,EAAQpC,QAAQ,KAAK,GADhD,SAEe9B,IAAKyD,KAAK9K,EAAOC,KAAKsL,EAAS,WAF9C,mF,oFAMA,SAAuBE,GAAa,IAAD,OACjC,OAAO,IAAIvE,SAAQ,SAACC,EAASC,GAE3B,IAAIC,IAAKvK,KAAeE,IAAqB6H,OAAO,GAAI9H,IAAc,YAAY,SAACuK,EAAKX,GAClFW,GAAOF,EAAOE,GAGlB,sBAAC,8BAAAtI,EAAA,sDAGUkE,EAAI,EAHd,YAGiBA,EAAIlG,IAAqB6H,QAH1C,iCAKuB,EAAK6G,gBAAgBD,EAAWzO,IAAqBkG,KAL5E,cAKOyI,EALP,gBAOShF,EAAMqE,KAAKW,GAAUzI,EAAE,GAAGpG,IAAa,GAPhD,OAGkDoG,IAHlD,gDAWQyD,EAAMyB,eAAe,cAX7B,2CAAD,GAYKrC,KAAKoB,EAASC,W,gCASzB,SAA0BqE,GAAa,IAAD,OAC9B3E,EAAQxC,KAAKsH,KAAKlN,IAAiBmG,QACzC,OAAO,IAAIqC,SAAQ,SAACC,EAASC,GAE3B,IAAIC,IAAKvK,IAAcgK,EAAO/J,IAAe+J,EAAO,YAAY,SAACQ,EAAKX,GAChEW,GAAOF,EAAOE,GAGlB,sBAAC,0CAAAtI,EAAA,sDAGKS,EAAa,GACboM,EAAY,GACP3I,EAAI,EALd,YAKiBA,EAAIlG,IAAqB6H,QAL1C,wBAOG0G,GADIA,EAAUE,EAAWzO,IAAqBkG,KAC5BsI,OAAOD,EAAQpC,QAAQ,KAAK,GAPjD,SAQ+C,EAAKuC,gBAAgBD,EAAWzO,IAAqBkG,KARpG,OAQGzD,EAAWzC,IAAqBkG,IARnC,OASG2I,EAAU7O,IAAqBkG,KAAM,EATxC,QAKkDA,IALlD,uBAaC,IAAS0D,EAAI,EAAGA,EAAIE,EAAOF,IACzB,IAASG,EAAI,EAAGA,EAAID,EAAOC,IAEnB+E,EAAM/E,EAAED,EAAQF,EACtBD,EAAMqE,KAAKvL,EAAWf,IAAiBoN,IAAOlF,EAAI9J,IAAaiK,EAAIhK,KAGnE8O,EAAUnN,IAAiBoN,KAAQ,EApBxC,OAyBOC,EAAW/O,IAAqBgP,QAAO,SAAAhN,GAAC,OAAK6M,EAAU7M,OAChD6F,OAAS,GACpBlC,QAAQwF,KAAK,+CAAgD4D,EAASE,KAAK,OA3B9E,kBA8BQtF,EAAMyB,eAAe,cA9B7B,2CAAD,GA+BKrC,KAAKoB,EAASC,W,6EASzB,WAAsCqE,EAAY3L,EAAWF,GAA7D,kGACMsM,EAAU,GADhB,uIAMUpI,EAAW9G,IAAqBkG,GAN1C,SAOmB,EAAKwI,gBAAgBD,EAAW3H,IAPnD,OA8BI,IAvBE/F,EAPN,OAQMoO,EAAgB,IAAIC,MAAMrO,EAAK8I,OAAOC,MAAQ/I,EAAK8I,OAAOG,QAC1DqF,EAAgBtL,IAAYjB,EAAUgE,GAAUoB,SAGlDnH,EAAK0K,KAAK,EAAG,EAAG1K,EAAK8I,OAAOC,MAAO/I,EAAK8I,OAAOG,QAAQ,SAACJ,EAAGG,GACzD,IAAMzF,EAAQvD,EAAKuM,cAAc1D,EAAGG,GAEpCoF,EAAcvF,EAAKG,EAAIhJ,EAAK8I,OAAOC,OAAUuF,EAAclD,QAAQ7H,MAIjEgL,EAAQH,EAAc1K,KAAK,SAAAmF,GAAC,OAAQ,EAAJA,KAClC2F,EAAQJ,EAAc1K,KAAI,SAAAmF,GAAC,OAAS,EAAJA,IAAa,KAM3C4F,EAAe,GAAIC,EAAe,GAAIC,EAAe,GAAIC,EAAe,GAC1EC,EAAe,GAAIC,EAAe,GAAIC,EAAe,GAAIC,EAAe,GAGjEC,EAAc,EAAGA,EAAc,EAAGA,IAGzC,IAASC,EAAI,EAAGA,EAAI,EAAGA,IAerB,IAZoB,IAAhBD,IACFR,EAAavD,KAAK,GAClBwD,EAAaxD,KAAK,GAClB2D,EAAa3D,KAAK,GAClB6D,EAAa7D,KAAK,GAClByD,EAAazD,KAAK,GAClB0D,EAAa1D,KAAK,GAClB4D,EAAa5D,KAAK,GAClB8D,EAAa9D,KAAK,IAIXiE,EAAI,EAAGA,EAAI,EAAGA,IACD,IAAhBF,GACFR,EAAaS,IAAMX,EAAOW,EAAIlP,EAAK8I,OAAOC,MAASoG,IAAO,EAAIA,EAC9DR,EAAaO,IAAMV,EAAOU,EAAIlP,EAAK8I,OAAOC,MAASoG,IAAO,EAAIA,GACrC,IAAhBF,GACTP,EAAaQ,IAAMX,EAAOW,EAAIlP,EAAK8I,OAAOC,MAASoG,EAAI,IAAO,EAAIA,EAClEP,EAAaM,IAAMV,EAAOU,EAAIlP,EAAK8I,OAAOC,MAASoG,EAAI,IAAO,EAAIA,GACzC,IAAhBF,GACTJ,EAAaK,IAAMX,EAAOW,EAAIlP,EAAK8I,OAAOC,MAASoG,EAAI,MAAS,EAAIA,EACpEL,EAAaI,IAAMV,EAAOU,EAAIlP,EAAK8I,OAAOC,MAASoG,EAAI,MAAS,EAAIA,IAEpEJ,EAAaG,IAAMX,EAAOW,EAAIlP,EAAK8I,OAAOC,MAASoG,EAAI,IAAM,IAAO,EAAIA,EACxEH,EAAaE,IAAMV,EAAOU,EAAIlP,EAAK8I,OAAOC,MAASoG,EAAI,IAAM,IAAO,EAAIA,GAQhFhB,EAAO,sBACFA,GACAM,EACAE,EACAD,EACAE,EACAC,EACAC,EACAC,EACAC,GA7ET,2CAKW7J,EAAI,EALf,YAKkBA,EAAIlG,IAAqB6H,QAL3C,0DAKmD3B,IALnD,yBAkFEgJ,EAAO,CACL,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACrB,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACrB,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACrB,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACrB,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACrB,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACrB,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACrB,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GARhB,mBASFA,IAKAtM,EAhGP,0CAiGW,IAAIO,WAAW+L,IAjG1B,QA2GE,IAHIiB,EAAiB,IAAIf,MAAM,MAAMgB,KAAK,GAGjClK,EAAI,EAAGA,EAAIlG,IAAqB6H,OAAO,EAAG3B,IAAK,CAWtD,IARM0D,EAAI1D,EAAI,EACZ6D,EAAIzC,KAAKC,MAAMrB,EAAI,GAEnBmK,EAAY,IAAmFtG,EAAM,GAAKH,EAAI,EAE9G0G,EAAwB,EAAJpK,EAAS,GAGtB+J,EAAI,EAAGA,EAAI,GAAIA,IACtBE,EAAeE,EAASJ,GAAKf,EAAQoB,EAAiBL,GAGxD,IAASA,EAAI,EAAGA,EAAI,GAAIA,IACtBE,EAAeE,EAAY,IAA+CJ,GAAKf,EAAQoB,EAAmBL,EAAI,IA3HpH,yBAgIS,IAAI9M,WAAWgN,IAhIxB,4C","file":"static/js/main.7f6210eb.chunk.js","sourcesContent":["export const IMAGE_WIDTH = 16;\nexport const IMAGE_HEIGHT = 16;\n\nexport const AVAILABLE_TILE_TYPES = [\n  'block',\n  'brick',\n  'bridge', \n  'plant', // Aka \"bush\"\n  'grass', \n  'hole',\n  'ladder',\n  'lava', \n  'rock', \n  'sand',\n  'stairs',\n  'tile',\n  'water',\n];\n\nexport const DEFAULT_TILE_TYPE = 'block';\n\nexport const TILE_BACKGROUND_COLORS = {\n  grass: 3,\n  water: 2,\n  lava: 3,\n  rock: 3, \n  brick: 2,\n  hole: 0,\n  plant: 3,\n  block: 3,\n  sand: 0,\n  bridge: 0,\n  ladder: 0,\n  stairs: 0,\n  tile: 3\n};\n\nexport const TILE_NAMES = {\n  grass: 'Grass',\n  water: 'Water',\n  lava: 'Lava',\n  block: 'Block',\n  brick: 'Brick Wall',\n  rock: 'Rock',\n  hole: 'Hole / Gap',\n  plant: 'Bush',\n  sand: 'Sand',\n  bridge: 'Bridge',\n  ladder: 'Ladder',\n  stairs: 'Stairs',\n  tile: 'Tile'\n}\n\nexport const TILE_PREVIEW_IDS = {\n  grass: [ \n    'grass', 'grass', 'grass', \n    'grass', 'grass', 'grass', \n    'grass', 'grass', 'grass',\n  ],\n  water: [\n    'water', 'water', 'water',\n    'water', 'water', 'water',\n    'water', 'water', 'water',\n  ],\n  lava: [\n    'sand', 'lava', 'lava',\n    'sand', 'lava', 'lava',\n    'sand', 'lava', 'lava',\n  ],\n  block: [\n    'block', 'block', 'block',\n    'block', 'grass', 'grass',\n    'block', 'grass', 'grass',\n  ],\n  brick: [\n    'brick', 'brick', 'brick',\n    'brick', 'brick', 'brick',\n    'grass', 'grass', 'grass', \n  ],\n  rock: [\n    'sand', 'sand', 'sand',\n    'rock', 'rock', 'rock',\n    'sand', 'sand', 'sand',\n  ],\n  hole: [\n    'sand', 'sand', 'sand',\n    'sand', 'hole', 'sand',\n    'sand', 'sand', 'sand',\n  ],\n  plant: [\n    'grass', 'grass', 'grass',\n    'grass', 'plant', 'grass',\n    'grass', 'grass', 'grass',\n  ],\n  sand: [\n    'sand', 'sand', 'sand',\n    'sand', 'sand', 'sand',\n    'sand', 'sand', 'sand',\n  ],\n  bridge: [\n    'water', 'water', 'water',\n    'bridge', 'bridge', 'bridge',\n    'water', 'water', 'water',\n  ],\n  ladder: [\n    'rock', 'ladder', 'rock',\n    'rock', 'ladder', 'rock',\n    'grass', 'grass', 'grass'\n  ],\n  stairs: [\n    'grass', 'grass', 'grass',\n    'grass', 'stairs', 'grass',\n    'grass', 'grass', 'grass',\n  ],\n  tile: [\n    'tile', 'tile', 'tile',\n    'tile', 'tile', 'tile',\n    'tile', 'tile', 'tile',\n  ]\n}\n\nexport const TILE_OPTIONS = {\n  grass: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Green'},\n    {name: 'Short Blades', min: 0, max: 10, type: 'range', defaultValue: 1},\n    {name: 'Tall Blades', min: 0, max: 10, type: 'range', defaultValue: 0},\n    {name: 'Triangles', min: 0, max: 8, type: 'range', defaultValue: 4}\n  ],\n  water: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Blue'},\n    {name: 'Lines', min: 2, max: 4, type: 'range'},\n    // Couldn't quite get what I wanted out of this - the areas kind of need to be relative to the lines, and \n    // that's a bit more complex than I'd hoped.\n    {name: 'Deeper Areas', min: 0, max: 3, type: 'range', disabled: true, defaultValue: 0}\n  ],\n  lava: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Red'},\n    {name: 'Frequency', min: 15, max: 25, type: 'range' },\n    {name: 'Offset', min: 0, max: 15, type: 'range'},\n    {name: 'Wave Width', min: 4, max: 8, type: 'range'}\n  ],\n  rock: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Yellow'},\n    {name: 'Rock Size', min: 3, max: 7, type: 'range'},\n    {name: 'Rock Color', type: 'color', defaultValue: 2},\n    {name: 'Rock Highlight Color', type: 'color', defaultValue: 3}\n  ],\n  brick: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Red'},\n    {name: 'Brick Width', min: 5, max: 12, type: 'range'},\n    {name: 'Brick Height', min: 2, max: 12, type: 'range'},\n    {name: 'Brick Color', type: 'color', defaultValue: 2}\n  ],\n  block: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Red'},\n    {name: 'Height', min: 4, max: 8, type: 'range'}\n  ],\n  tile: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Red'},\n    {name: 'Height', min: 2, max: 3, type: 'range'}\n  ],\n  hole: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Yellow'},\n    {name: 'Hole Size', min: 6, max: 14, type: 'range', step: 2},\n    {name: 'Fuzz Area', min: 1, max: 2, type: 'range', defaultValue: 1}\n  ],\n  plant: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Green'},\n    {name: 'Bush Size', min: 3, max: 6, type: 'range'},\n    {name: 'Bush Color', type: 'color', defaultValue: 2},\n    {name: 'Freckle Color', type: 'color', defaultValue: 1},\n    {name: 'Freckle Count', min: 2, max: 8, type: 'range'},\n    {name: 'Freckle Size', min: 1, max: 2, type: 'range', defaultValue: 1}\n  ],\n  sand: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Yellow'},\n    {name: 'Frequency', min: 15, max: 75, type: 'range' },\n    {name: 'Offset', min: 0, max: 15, type: 'range'},\n    {name: 'Wave Width', min: 3, max: 12, type: 'range'}\n  ],\n  bridge: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Red'},\n    {name: 'Board Width', min: 3, max: 9, type: 'range', step: 2, defaultValue: 7},\n    {name: 'Border Width', min: 0, max: 2, type: 'range', defaultValue: 1},\n    {name: 'Board Color', type: 'color', defaultValue: 1},\n    {name: 'Separator Color', type: 'color', defaultValue: 0},\n  ],\n  ladder: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Blue'},\n    {name: 'Step Width', min: 3, max: 9, type: 'range', step: 2, defaultValue: 3},\n    {name: 'Border Width', min: 0, max: 2, type: 'range', defaultValue: 1},\n    {name: 'Step Color', type: 'color', defaultValue: 3},\n    {name: 'Separator Color', type: 'color', defaultValue: 1},\n  ],\n  stairs: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Red'},\n    {name: 'Step Width', min: 3, max: 9, type: 'range', step: 2, defaultValue: 7},\n    {name: 'Step Height', min: 1, max: 3, type: 'range'},\n    {name: 'Border Width', min: 0, max: 2, type: 'range', defaultValue: 1},\n    {name: 'Step Color', type: 'color', defaultValue: 1},\n    {name: 'Separator Color', type: 'color', defaultValue: 0},\n  ],\n\n\n};\n  \nexport const TILE_PREVIEW_MAP = [\n  'brick', 'brick', 'ladder', 'brick', 'grass', 'grass', 'grass', 'grass', 'block', 'tile', 'tile', 'tile',\n  'grass', 'grass', 'grass', 'grass', 'grass', 'plant', 'plant', 'grass', 'block', 'tile', 'stairs', 'tile',\n  'grass', 'grass', 'plant', 'plant', 'grass', 'plant', 'plant', 'grass', 'block', 'tile', 'tile', 'tile',\n  'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'block', 'block', 'block', 'block',\n  'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass',\n  'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass',\n  'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass',\n  'sand' , 'sand' , 'sand' , 'sand' ,  'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass',\n  'water', 'water', 'water', 'sand' , 'sand', 'grass', 'grass', 'grass', 'grass', 'grass', 'lava', 'lava',\n  'water', 'water', 'water', 'sand' , 'sand', 'sand', 'grass', 'grass', 'grass', 'grass', 'lava', 'lava',\n  'bridge', 'bridge', 'bridge', 'sand' , 'sand', 'sand', 'sand', 'hole', 'sand', 'sand', 'lava', 'lava',\n  'water', 'water', 'water', 'sand' , 'rock', 'sand', 'sand', 'hole', 'sand', 'sand', 'lava', 'lava',\n];","import SlDropdown from '@shoelace-style/react/dist/dropdown';\nimport SlMenuItem from '@shoelace-style/react/dist/menu-item';\nimport SlButton from '@shoelace-style/react/dist/button';\nimport SlMenu from '@shoelace-style/react/dist/menu';\nimport React from 'react';\n\nimport ImageGenerator from '../services/image-generator';\n\nimport { nesPaletteData } from '../constants/palette-constants';\n\nconst decoder = new TextDecoder('utf8');\n\n// Renders a dropdown with options to downloda all images\n// Props:\n// - tileImages: Collection of images to use for the given ids\n// - tileProps: Collection of properties around tiles, used to get palette\nexport default class MapPreviewButton extends React.Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  forceDownload(data, name) {\n    // Force a download, the new old-fashioned way\n    let a = document.createElement(\"a\");\n    a.href = data; \n    a.download = name;\n    a.click();\n  }\n\n  async downloadAll() {\n    const img = await ImageGenerator.generateFullSet(this.props.tileImages);\n    this.forceDownload(img, 'Tileset.png');\n  }\n\n  async downloadBin(organizeIntoBlocks) {\n    const img = await ImageGenerator.generateNesPatternTables(this.props.tileImages, this.props.tileProps, organizeIntoBlocks);\n    const b64data = 'data:application/octet-stream;base64,' + Buffer.from(img).toString('base64');\n    this.forceDownload(b64data, '2bit-tile-generator.chr');\n  }\n\n  async downloadPalette() {\n    let data = new Uint8Array([\n      ...nesPaletteData['NES Default Blue'], \n      ...nesPaletteData['NES Default Red'], \n      ...nesPaletteData['NES Default Green'], \n      ...nesPaletteData['NES Default Yellow']\n    ]);\n    // To base64 url string\n    const b64data = 'data:application/octet-stream;base64,' + Buffer.from(data).toString('base64');\n    this.forceDownload(b64data, '2bit-tile-generator.pal');\n  }\n\n  render() {\n    return <span>\n      <SlDropdown>\n        <SlButton caret slot=\"trigger\">Download</SlButton>\n        <SlMenu>\n          <SlMenuItem title=\"Download a single png file with all tiles\" onClick={() => this.downloadAll()}>Download Tile Strip (.png)</SlMenuItem>\n          <SlMenuItem title=\"Download NES binary data, with tile data organized linearly (for games, nesst, etc)\" onClick={() => this.downloadBin(false)}>Download linear binary format (.chr)</SlMenuItem>\n          <SlMenuItem title=\"Download NES binary data, with all tiles organized visually into 16x16 tiles (for games, nesst, etc)\" onClick={() => this.downloadBin(true)}>Download organized binary format (.chr)</SlMenuItem>\n          <SlMenuItem title=\"Download Default NES Palette file (games, nesst, etc)\" onClick={() => this.downloadPalette()}>Download binary palette (.pal)</SlMenuItem>\n        </SlMenu>\n      </SlDropdown>\n    </span>;\n    \n  }\n}","export const availablePalettes = [\n    'Gameboy',\n    'NES Default Red',\n    'NES Default Blue',\n    'NES Default Green',\n    'NES Default Yellow'\n];\n\nexport const paletteData = {\n    // NOTE: These colors are exact matches that gbtd understands. Don't change just to make pretty!\n    // (or at least make a separate palette)\n    'Gameboy': [0x000000ff, 0x808080ff, 0xc0c0c0ff, 0xffffffff],\n    'NES Default Blue': [0x000000ff, 0x00008fff, 0x4488ffff, 0x99ccffff],\n    'NES Default Red': [0x000000ff, 0x550000ff, 0x993300ff, 0xdd6644ff],\n    'NES Default Green': [0x000000ff, 0x113300ff, 0x336600ff, 0x77bb00ff],\n    'NES Default Yellow': [0x000000ff, 0x666600ff, 0xbbaa00ff, 0xeedd88ff]\n}\n\n// Used to build up an actual NES palette, for download\nexport const nesPaletteData = {\n    'Gameboy': [0x0f, 0x00, 0x10, 0x30],\n    'NES Default Blue': [0x0f, 0x01, 0x21, 0x31],\n    'NES Default Red': [0x0f, 0x06, 0x16, 0x26],\n    'NES Default Green': [0x0f, 0x09, 0x19, 0x29],\n    'NES Default Yellow': [0x0f, 0x08, 0x18, 0x28]\n}\n\nexport const getPalette = (idOrName) => {\n    if (typeof idOrName === 'string') {\n        return paletteData[idOrName];\n    } else {\n        return paletteData[availablePalettes[idOrName]];\n    }\n}","import React from 'react';\nimport './palette-color-preview.css';\n\n// Given a hex color, create a component with that as the background color\n// props: \n// - color: A hex color in rgba format -including alpha. Example: 0xff00ffff\nexport default class PaletteColorPreview extends React.Component {\n\n  render() {\n    return <div className=\"palette-color-preview\" style={{backgroundColor: '#' + this.props.color}}></div>;\n  }\n}","import React from 'react';\nimport './palette-preview.css';\n\nimport PaletteColorPreview from './palette-color-preview';\n\n// Given an array of colors in rgba hex numeral format, draw the palette as dom elements.\n// Props:\n// - palette: An array of colors, in hex format, including alpha. eg 0xff00ffff\nexport default class PalettePreview extends React.Component {\n  render() {\n    return <div className=\"palette-preview\">\n      {this.props.palette.map(a => <PaletteColorPreview key={'prev-' + a} color={a.toString(16).padStart(8, '0')}></PaletteColorPreview>)}\n    </div>;\n  }\n}","import React from 'react';\nimport './tile-setting.css';\n\nimport SlRadio from '@shoelace-style/react/dist/radio';\nimport SlRadioGroup from '@shoelace-style/react/dist/radio-group';\nimport SlRange from '@shoelace-style/react/dist/range';\nimport SlSelect from '@shoelace-style/react/dist/select';\nimport SlMenuItem from '@shoelace-style/react/dist/menu-item';\n\nimport { availablePalettes, getPalette } from '../constants/palette-constants';\n\nimport PaletteColorPreview from './palette-color-preview';\nimport PalettePreview from './palette-preview';\n\n// Given a setting property (such as those defined in tile-constants), render it as a configurable setting.\n// Available types are: range, color, and palette\n// props: \n// - setting: The settings object from constants. Keys detailed there\n// - state: The application state surrounding this thing. This is kind of clunky, and a workaround for redux!\n// - tileTypeId: A 'type' of tile, the key for the settings object.\nexport default class TileSetting extends React.Component {\n  setting = null;\n  state = null;\n  tileTypeId = null;\n  updateTileState = () => {};\n  constructor(props) {\n    super(props);\n    this.state = props.state;\n    this.reloadFromProps(props);\n  }\n\n  // Make sure this component always refreshes when props change.\n  // NOTE: We would be far better served by a redux pattern here, but that's more effort than I'd care\n  // to put in at this stage. At some point we might want to migrate to something better.\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    this.reloadFromProps(nextProps);\n    this.setState(nextProps.state);\n  }\n\n  reloadFromProps(props) {\n    this.setting = props.setting;\n    this.tileTypeId = props.tileTypeId;\n    this.updateTileState = (a, b, c) => {\n        props.updateTileState(a, b, c);\n    };\n  }\n\n  render() {\n    const setting = this.setting;\n\n    if (setting.disabled || setting === null) { return <span key={\"disabled-setting-\" + setting.type + setting.name}></span>; }\n    switch (setting.type) {\n      case 'range':\n        // This could probably be a component of its\n        return <div className=\"tile-option\" key={\"range-\" + setting.type + setting.name}>\n            <SlRange key={this.tileTypeId + setting.name} \n              min={setting.min} \n              max={setting.max} \n              step={setting.step || 1} \n              label={setting.name} \n              value={this.state.tileProps[this.tileTypeId][setting.name]} \n              onSlChange={e => this.updateTileState(this.tileTypeId, setting.name, e.target.value)}>\n            </SlRange>\n            <div className=\"below-range\">\n              <small className=\"left\">{setting.min}</small>\n              <small className=\"mid\">Current: {this.state.tileProps[this.tileTypeId][setting.name]}</small>\n              <small className=\"right\">{setting.max}</small>\n            </div>\n          </div>;\n      case 'color':\n        return <div className=\"tile-option\" key={\"palette-\" + setting.type + setting.name}>\n          <SlRadioGroup label={setting.name}>\n            {[0, 1, 2, 3].map(n => {\n              return <SlRadio \n                  value={n} \n                  checked={this.state.tileProps[this.tileTypeId][setting.name] === n ? true : false} \n                  key={\"palette-color\" + setting.type + setting.name + '-' + n} \n                  onSlChange={e => e.target.checked ? this.updateTileState(this.tileTypeId, setting.name, n) : null}\n                >\n                  Color {n+1} \n                  <PaletteColorPreview color={getPalette(this.state.tileProps[this.tileTypeId]['Palette'])[n].toString(16).padStart(8, '0')}></PaletteColorPreview>\n                </SlRadio>\n            })}\n          </SlRadioGroup>\n        </div>\n      case 'palette':\n        return <div className=\"tile-option\" key={'palette-' + setting.type + setting.name}>\n          <SlSelect \n            label=\"Palette Color\" \n            value={this.state.tileProps[this.tileTypeId][setting.name]}\n            onSlChange={e => this.updateTileState(this.tileTypeId, setting.name, e.target.value)}>\n              {availablePalettes.map(a => <SlMenuItem key={a} value={a}>{a} <PalettePreview palette={getPalette(a)}></PalettePreview></SlMenuItem>)}\n          </SlSelect>\n        </div>\n      default:\n        console.error(`Unknown tile option type \"${setting.type}\" found!`, setting);\n        return <span></span>;\n    }\n\n  }\n}","import React from 'react';\nimport './tiled-image.css';\n\nimport { TILE_PREVIEW_IDS } from '../constants/tile-constants';\n\n// Renders an image in a tiled pattern, sizeXsize wide\n// Props:\n// - tileId: The id of the tile to render, looked up from constants\n// - tileImages: Collection of images to use for the given ids\nexport default class TiledImage extends React.Component {\n  render() {\n    const allSrc = TILE_PREVIEW_IDS[this.props.tileId].map(id => this.props.tileImages[id]);\n    return <div className=\"tile-preview-collection\">\n      {allSrc.map((src, i) => <img alt=\"\" src={src} key={'preview-' + i}></img>)}\n    </div>\n  }\n}","import SlButton from '@shoelace-style/react/dist/button';\nimport SlDialog from '@shoelace-style/react/dist/dialog';\nimport SlTooltip from '@shoelace-style/react/dist/tooltip';\nimport React from 'react';\n\nimport ImageGenerator from '../services/image-generator';\n\nimport './map-preview-button.css';\n\n// Renders a preview map with the given images. simulates a simple game map\n// Props:\n// - tileImages: Collection of images to use for the given ids\nexport default class MapPreviewButton extends React.Component {\n\n  constructor(props) {\n    super(props);\n    this.imageRef = React.createRef();\n    this.state = {mapImage: null};\n  }\n\n  async showDialog() {\n    const img = await ImageGenerator.generateMapPreview(this.props.tileImages);\n    this.setState({mapImage: img});\n    // This should always be set - I used the ? to avoid issues with some hacky test code I wrote\n    this.imageRef?.current?.show();\n  }\n\n\n  render() {\n    return <span>\n      <SlTooltip content=\"Show a preview image using all of the tiles\">\n        <SlButton onClick={() => this.showDialog()}>Preview as map</SlButton>\n      </SlTooltip>\n      <SlDialog label=\"Map Preview\" ref={this.imageRef} className=\"map-preview-dialog\">\n        <img alt=\"Map Preview\" src={this.state.mapImage}></img>\n      </SlDialog>\n    </span>;\n    \n  }\n}","import React from 'react';\n\n// Shoelace components\nimport '@shoelace-style/shoelace/dist/themes/base.css';\nimport SlButton from '@shoelace-style/react/dist/button';\nimport SlSelect from '@shoelace-style/react/dist/select';\nimport SlMenuItem from '@shoelace-style/react/dist/menu-item';\nimport SlTooltip from '@shoelace-style/react/dist/tooltip';\n\n// Services\nimport ImageGenerator from './services/image-generator';\n\n// Custom components\nimport TileSetting from './components/tile-setting';\nimport TiledImage from './components/tiled-image';\nimport MapPreviewButton from './components/map-preview-button';\nimport DownloadDropdown from './components/download-dropdown';\n\n// Constants\nimport { TILE_NAMES, TILE_OPTIONS, AVAILABLE_TILE_TYPES, DEFAULT_TILE_TYPE } from './constants/tile-constants';\nimport { getPalette } from './constants/palette-constants';\n\nimport './App.css';\n// Huge app component that could probably be broken down well if I got smart with a Store for state\nclass App extends React.Component {\n\n  // Initializer, mostly sets up initial state of the application\n  constructor(props) {\n    super(props);\n    this.state = {\n      tileType: DEFAULT_TILE_TYPE,\n      tileProps: {},\n      // Default palette, if one is not provided via options.\n      palette: getPalette(0),\n      // Transparent 1px gif so we don't show a broken image\n      currentTileImg: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',\n      builtTileImages: {}\n    }\n\n    // NOTE: This logic is almost-duplicated in the reRandomize method\n    AVAILABLE_TILE_TYPES.forEach(t => {\n\n      // Seriously, it's a constructor. The react docs do this. Calm down, eslint.\n      // eslint-disable-next-line\n      this.state.tileProps[t] = {};\n\n      TILE_OPTIONS[t].forEach(opt => {\n        if (opt.defaultValue !== undefined) {\n          // eslint-disable-next-line\n          this.state.tileProps[t][opt.name] = opt.defaultValue;\n        } else if (opt.min !== undefined && opt.max !== undefined) {\n          let val = Math.floor(Math.random() * (opt.max - opt.min +1)) + opt.min;\n\n          // Enforce the step size in randomization\n          if (opt.step) { \n            val -= (val % opt.step); \n          }\n          // es-lint-disable-next-line\n          this.state.tileProps[t][opt.name] = val;\n        }\n      });\n      this.state.builtTileImages[t] = null;\n    });\n\n\n    // Try to retrieve the last tile you were using to restore state\n    try {\n      const lastTileType = localStorage.getItem('2bit-tile-generator__tileType');\n      if (lastTileType !== null) {\n        this.state.tileType = lastTileType;\n      }\n    } catch (e) {\n      console.info('Failed getting information from localStorage, sticking to default', e);\n    }\n  }\n\n  // Generate the images as soon as this is rendered (else we'll call setState too early)\n  async componentDidMount() {\n    for (let i = 0; i < AVAILABLE_TILE_TYPES.length; i++) {\n      await this.generateTileImage(AVAILABLE_TILE_TYPES[i], false);\n    }\n\n    this.reloadImage();\n  }\n\n  // NOTE: This logic is almost-duplicated in the constructor, with defaults and without the disabled check.\n  reRandomize() {\n    let newState = {tileProps: {...this.state.tileProps}};\n    AVAILABLE_TILE_TYPES.forEach(t => {\n      newState.tileProps[t] = {...this.state.tileProps[t]};\n      TILE_OPTIONS[t].forEach(opt => {\n        if (!opt.disabled) {\n          if (opt.min !== undefined && opt.max !== undefined) {\n            let val = Math.floor(Math.random() * (opt.max - opt.min + 1)) + opt.min;\n\n            // Enforce the step sizein randomization\n            if (opt.step) { \n              val -= (val % opt.step); \n            }\n\n            newState.tileProps[t][opt.name] = val;\n          }\n        }\n      });\n    });\n    this.setState(newState, this.reloadImage);\n  };\n\n  async generateTileImage(tileType, force = false) {\n    let palette = this.state.palette;\n    if (this.state.tileProps[tileType].Palette) {\n      palette = getPalette(this.state.tileProps[tileType].Palette);\n    }\n    if (this.state.builtTileImages[tileType] === null || force) {\n      let res = await ImageGenerator.generateImage(tileType, this.state.tileProps[tileType], palette);\n      this.setState({builtTileImages: {\n        ...this.state.builtTileImages,\n        [tileType]: res\n      }});\n      return res;\n    }\n    return this.state.builtTileImages[tileType];\n\n  }\n\n  // Redraw the image based on current state.\n  async getCurrentTileImage(force = false) {\n    return await this.generateTileImage(this.state.tileType, force);\n  }\n\n  // Rebuild the image shown on the page from available settings.\n  async reloadImage(force = true) {\n    this.setState({currentTileImg: await this.getCurrentTileImage(force)});\n  }\n\n  // Helper function to do exactly what it says. Regenerates the image when it's done.\n  updateTileType(event) {\n    this.setState({tileType: event.target.value}, () => this.reloadImage(false));\n    localStorage.setItem('2bit-tile-generator__tileType', event.target.value);\n  }\n\n  // Helper to update state values from the various components that we support.\n  updateTileState(typeName, name, value) {\n    // Test to make sure the value changed to avoid infinite loops from radio buttons triggering this repeatedly\n    if (this.state.tileProps[typeName][name] === value) { \n      return;\n    }\n\n    // React will stomp any nested objects when you use this, so we have to bring in the old state\n    this.setState({\n      tileProps: {\n        ...this.state.tileProps,\n        [typeName]: {\n          ...this.state.tileProps[typeName],\n          [name]: value\n        }\n      }\n    }, this.reloadImage);\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <h1>2Bit Tile Generator</h1>\n        </header>\n        <section>\n\n          <div className=\"control-bar\">\n            <MapPreviewButton tileImages={this.state.builtTileImages}></MapPreviewButton>\n            <DownloadDropdown tileImages={this.state.builtTileImages} tileProps={this.state.tileProps}></DownloadDropdown>\n\n            <SlTooltip content=\"Randomize the settings for all tiles.\">\n              <SlButton onClick={() => this.reRandomize()}>Randomize Settings</SlButton>\n            </SlTooltip>\n            <SlTooltip content=\"Regenerate tile image with the current settings\">\n              <SlButton onClick={() => this.reloadImage(true)}>Regenerate</SlButton>\n            </SlTooltip>\n          </div>\n\n          <div className=\"configurator\">\n            <div className=\"left\">\n              <h3>Tile Preview</h3>\n\n              <h4>Single</h4>\n              <img className=\"tile-preview\" alt=\"Tile Preview\" src={this.state.currentTileImg}></img>\n              <h4>Tiled</h4>\n              <TiledImage tileId={this.state.tileType} tileImages={this.state.builtTileImages}></TiledImage>\n              <div className=\"dl-bar\">\n                <SlButton href={this.state.currentTileImg} download={this.state.tileType + '.png'}>Download</SlButton>\n              </div>\n            </div>\n            <div className=\"right\">\n              <h3>Tile Configuration</h3>\n              <div className=\"tile-option\">\n                <SlSelect label=\"Tile Type\" value={this.state.tileType} onSlChange={e => this.updateTileType(e)} className=\"tile-type-select\">\n                  {AVAILABLE_TILE_TYPES.map(a => <SlMenuItem key={a} value={a}>{TILE_NAMES[a]} <img alt=\"\" slot=\"suffix\" src={this.state.builtTileImages[a]}></img> </SlMenuItem>)}\n                </SlSelect>\n              </div>\n\n              {TILE_OPTIONS[this.state.tileType].map(setting => \n                <TileSetting \n                  key={this.state.tileType + setting.name}\n                  setting={setting} \n                  state={this.state} \n                  tileTypeId={this.state.tileType} \n                  updateTileState={(a, b, c) => this.updateTileState(a, b, c)\n                }></TileSetting>\n              )}\n            </div>\n          </div>\n        </section>\n        <footer>\n          <p>\n            Heavily inspired by <a href=\"https://0x72.itch.io/2bitcharactergenerator\" target=\"_blank\">0x72's 2BitCharactersGenerator</a>. \n            UI powered by <a href=\"https://shoelace.style/\" target=\"_blank\">Shoelace</a>.\n          </p>\n\n          <p>\n            All images generated by this tool are free for use. (CC0) Tool available under the MIT license. (\n            <a href=\"https://github.com/cppchriscpp/2bit-tile-generator\" target=\"_blank\">Source</a> • {' '}\n            <a href=\"https://github.com/cppchriscpp/2bit-tile-generator/issues\" target=\"_blank\">Feature Requests</a>) \n            </p>\n          <p>\n            There is no requirement to credit me, but please consider tweeting me if you find this useful! {' '}\n            <a href=\"https://twitter.com/cppchriscpp\" target=\"_blank\">@cppchriscpp</a>\n          </p>\n          <p>Wanna see the other stuff I do? Check out <a href=\"https://cpprograms.net\" target=\"_blank\">cpprograms.net</a>.</p>\n          <SlTooltip content=\"Click for changelog\">\n            <a className=\"version\" href=\"https://github.com/cppchriscpp/2bit-tile-generator/blob/main/CHANGELOG.md\" target=\"_blank\">version {process.env.REACT_APP_VERSION}</a>\n          </SlTooltip>\n        </footer>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","import Jimp from 'jimp/es';\nimport { paletteData } from '../constants/palette-constants';\n\nimport { TILE_BACKGROUND_COLORS, IMAGE_WIDTH, IMAGE_HEIGHT, AVAILABLE_TILE_TYPES, TILE_PREVIEW_MAP } from '../constants/tile-constants';\n\n// Because js treats % as a remainder instead of modulus... because, sigh, programming languages were a mistake.\nfunction modulus(a, b) {\n  return ((a % b ) + b) % b;\n}\n\n// Helper to find a random position within the image\nfunction getRandomImageCoords(image) {\n  let x = Math.floor(Math.random() * image.bitmap.width);\n  let y = Math.floor(Math.random() * image.bitmap.height);\n\n  return {x, y};\n}\n\n\n/**\n * Image generation logic. Used to generate all of the various images using Jimp.\n * Define available image types in the constants in ../tile-constants\n * \n * Jimp doesn't have any primitive drawing ability, and I can't find a library to do it. Maybe I'll make one by myself, but until\n * such a time, things are done manually here. (and very, very clumsily)\n */\nexport default class ImageGenerator {\n  // Really just a home for static methods for now. Don't even construct it.\n\n  static generateImage(tileType, tileOpt, palette) {\n    // Jimp isn't super promise friendly - technically it works but it's pretty sketchy at times. Wrap this instead.\n    return new Promise((resolve, reject) =>{\n      new Jimp(IMAGE_WIDTH, IMAGE_HEIGHT, palette[TILE_BACKGROUND_COLORS[tileType]], async (err, image) =>{\n        if (err) { reject(err); }\n\n        // Big, kind of ugly switch statement for each of our available tile types, determining how to draw each one.\n        switch (tileType) {\n          case 'grass': \n          await ImageGenerator.drawGrass(image, tileOpt, palette);\n            break;\n          case 'water':\n            await ImageGenerator.drawWater(image, tileOpt, palette);\n            break;\n          case 'brick':\n            await ImageGenerator.drawBrick(image, tileOpt, palette);\n            break;\n          case 'tile':\n          case 'block':\n            await ImageGenerator.drawBlock(image, tileOpt, palette);\n            break;\n          case 'hole':\n            await ImageGenerator.drawHole(image, tileOpt, palette);\n            break;\n          case 'plant':\n            await ImageGenerator.drawPlant(image, tileOpt, palette);\n            break;\n          case 'rock':\n            await ImageGenerator.drawRock(image, tileOpt, palette);\n            break;\n          case 'lava':\n            await ImageGenerator.drawLava(image, tileOpt, palette);\n            break;\n          case 'sand':\n            await ImageGenerator.drawSand(image, tileOpt, palette);\n            break;\n          case 'bridge':\n            await ImageGenerator.drawBridge(image, tileOpt, palette);\n            break;\n          case 'ladder':\n            await ImageGenerator.drawLadder(image, tileOpt, palette);\n            break;\n          case 'stairs':\n            await ImageGenerator.drawStairs(image, tileOpt, palette);\n            break;\n          default: \n            console.warn('Unimplemented tile type given!', tileType, 'blank image ahoy');\n        }\n\n        image.getBase64Async('image/png').then(resolve, reject);\n      });\n\n\n    });\n  }\n\n  static drawGrass(image, tileOpt, palette) {\n    for (let i = 0; i < tileOpt['Short Blades']; i++) {\n      const {x, y} = getRandomImageCoords(image);\n      image.setPixelColor(palette[2], x, y);\n    }\n    for (let i = 0; i < tileOpt['Tall Blades']; i++) {\n      const {x, y} = getRandomImageCoords(image);\n      image.setPixelColor(palette[2], x, y);\n      image.setPixelColor(palette[2], x, y === 0 ? (image.bitmap.height - 1) : y-1);\n    }\n\n    for (let i = 0; i < tileOpt['Triangles']; i++) {\n      const {x, y} = getRandomImageCoords(image);\n\n      image.setPixelColor(palette[2], x > 0 ? x-1 : (image.bitmap.width - 1), y);\n      image.setPixelColor(palette[2], x < (image.bitmap.width - 1) ? x+1 : 0, y);\n      image.setPixelColor(palette[2], x, y > 0 ? y-1 : (image.bitmap.height - 1));\n    }\n  }\n\n  static drawWater(image, tileOpt, palette) {\n\n    // Disabled, this didn't end up looking good, tries to fill in deeper areas in a circle around a random point\n    for (let i = 0; i < tileOpt['Deeper Areas']; i++) {\n      const {x: originX, y: originY} = getRandomImageCoords(image);\n      const depthR = Math.floor(Math.random() * 4) + 3;\n\n      image.scan(0, 0, image.bitmap.width, image.bitmap.height, (x, y, idx) => {\n        const dx = originX - x;\n        const dy = originY - y;\n        if (dx*dx + dy*dy <= (depthR*depthR)) {\n          image.setPixelColor(palette[1], x, y);\n        }\n      });\n    }\n\n    // Draw lines starting from a random spot on the image\n    for (let i = 0; i < tileOpt['Lines']; i++) {\n      // Start position\n      const {x: originX, y: originY} = getRandomImageCoords(image);\n      // Determine which direction this line is facing, left/right and up/down\n      const xDiff = Math.floor(Math.random() * 2) === 1 ? 1 : -1;\n      const yDiff = Math.floor(Math.random() * 2) === 1 ? 1 : -1;\n      let x = originX, y = originY;\n      // Set that first pixel manually\n      image.setPixelColor(palette[3], x, y);\n      x = modulus(x + xDiff, image.bitmap.width);\n      y = modulus(y + yDiff, image.bitmap.height);\n      \n      // Repeat this process until we've gone across the full width of the image\n      while (x !== originX && y !== originY) {\n        image.setPixelColor(palette[3], x, y);\n\n        // Pick whether to shift by x, y, neither or both. (It eventually works out)\n        if (Math.random() > 0.3) {\n          // Modulus loops us back over to 0 when we hit the full width\n          x = modulus(x + xDiff, image.bitmap.width);\n        }\n        if (Math.random() > 0.3) {\n          y = modulus(y + yDiff, image.bitmap.height);\n        }\n\n      }\n      // Set the last pixel that was set up in the while loop\n      image.setPixelColor(palette[3], x, y);\n    }\n\n  }\n\n  static drawBrick(image, tileOpt, palette) {\n    const row1Lines = [];\n    const row2Lines = [];\n    // Find where in each row to put the column lines - we have 2 sets, offset by brick width to provide some variation.\n    for (var i = 0; i < image.bitmap.width; i++) {\n      if (modulus(i+1, tileOpt['Brick Width'] + 1) === 0) {\n        row1Lines.push(i);\n      } else if (modulus(i + 1 + Math.floor(tileOpt['Brick Width'] / 2), tileOpt['Brick Width'] + 1) === 0) {\n        row2Lines.push(i);\n      }\n    }\n\n    let rowNum = 0;\n    image.scan(0, 0, image.bitmap.width, image.bitmap.height, (x, y, idx) => {\n      // Fill with bg color to start\n      image.setPixelColor(palette[tileOpt['Brick Color']], x, y);\n\n      // Color brick with border color if this is a border between bricks\n      if (y % (tileOpt['Brick Height'] + 1) === 0) {\n        image.setPixelColor(palette[0], x, y);\n\n        // If this is the first pixel in this row, up the row number, so we can decide which column to use\n        if (x === 0) { ++rowNum; }\n      }\n\n      // If this matches the X for an active column, draw that too\n      if (rowNum % 2 === 0) {\n        if (row1Lines.indexOf(x) !== -1) {\n          image.setPixelColor(palette[0], x, y);\n        }\n      } else {\n        if (row2Lines.indexOf(x) !== -1) {\n          image.setPixelColor(palette[0], x, y);\n        }\n      }\n    });\n\n  }\n\n  static drawBlock(image, tileOpt, palette) {\n    image.scan(0, 0, image.bitmap.width, image.bitmap.height, (x, y) => {\n      const tileSize = (10 - tileOpt['Height']) * 2;\n\n      // Draw a diagonal line across the image, with darker color on the bottom half to show shading\n      image.setPixelColor(x > (image.bitmap.height - y - 1) ? palette[1] : palette[3], x, y);\n\n      \n      // Draw a line across both diagonals, to show where the edges are\n      // NOTE: This also hides some messiness that might be made with the diagonal line above\n      if (x === y) {\n        image.setPixelColor(palette[2], x, y);\n      } else if (x === (image.bitmap.height - y - 1)) {\n        image.setPixelColor(palette[1], x, y);\n      }\n\n      // This is used to determine the \"height\" of the block, which is really the square in the middle, and how big it is\n      const h = ((image.bitmap.height / 2) - (tileSize / 2));\n      \n      // Draw the variable-sized square in the middle\n      if (x > h && x < (h + tileSize - 1)) {\n        if (y > h && y < (h + tileSize - 1)) {\n          image.setPixelColor(palette[2], x, y);\n        }\n      }\n    });\n  }\n\n  static drawHole(image, tileOpt, palette) {\n    const borderWidth = Math.floor((image.bitmap.width / 2) - (tileOpt['Hole Size'] / 2));\n    // Determine how much space to randomly fill with either bg or hole color\n    const fuzzWidth = tileOpt['Fuzz Area']; \n\n    image.scan(0, 0, image.bitmap.width, image.bitmap.height, (x, y) => {\n      // The image currently has a background color that we want, so now we find what parts need to be recolored to black for the hole\n      \n      // Test to make sure we're within he borders of the whole\n      if (\n        (x < borderWidth || x > (image.bitmap.width - 1 - borderWidth)) ||\n        (y < borderWidth || y > (image.bitmap.height - 1 - borderWidth))\n      ) {\n        \n        // Determine whether we are in the \"fuzzy\" area on the outside of the hole\n        if (\n          (x >= (borderWidth - fuzzWidth) && x < borderWidth && (y > borderWidth && y < (image.bitmap.height - 1 - borderWidth))) ||\n          (x >= (borderWidth + tileOpt['Hole Size']) && x < (borderWidth + tileOpt['Hole Size'] + fuzzWidth) && (y > borderWidth && y < (image.bitmap.height -1 - borderWidth))) ||\n          \n          (y >= (borderWidth - fuzzWidth) && y < borderWidth && (x > borderWidth && x < (image.bitmap.width - 1 - borderWidth))) ||\n          (y >= (borderWidth + tileOpt['Hole Size']) && y < (borderWidth + tileOpt['Hole Size'] + fuzzWidth) && (x > borderWidth && x < (image.bitmap.width -1 - borderWidth)))\n        ) {\n          // We're in the fuzzy area, so bail based on rng, causing this pixel to stay as the background color\n          if (Math.random() > 0.35) { return; }\n        }\n        // If you get here, set the background color to black, the hole color.\n        image.setPixelColor(palette[2], x, y);\n      }\n    });\n\n  }\n\n  static drawPlant(image, tileOpt, palette) {\n\n    // Draw a circle around the outside\n    const r = tileOpt['Bush Size'];\n    const x = 8, y = 10 - Math.floor(tileOpt['Bush Size'] / 2);\n    \n    let angle, x1, y1;\n    for (var i = 0; i < 360; i++) {\n      angle = i;\n      x1 = r * Math.cos(angle * Math.PI / 180);\n      y1 = r * Math.sin(angle * Math.PI / 180);\n\n      image.setPixelColor(palette[0], Math.round(x + x1), Math.round(y + y1));\n    }\n\n    // Loop over the whole image, row by row,\n    for (var imgY = 0; imgY < image.bitmap.height; imgY++) {\n      // Track whether, in this row, we have hit the first border, a pixel of filling, and the right border.\n      let hitLeft = false, hitMid = false, hitRight = false, colorCount = 0;\n      // Loop over each pixel\n      for (var imgX = 0; imgX < image.bitmap.width; imgX++) {\n        // Check the pixel color, see if it matches the border color (always [0])\n        if (image.getPixelColor(imgX, imgY) === palette[0]) {\n          colorCount++;\n          if (!hitLeft) { // If we haven't seen this before, this is the lefthand side\n            hitLeft = true;\n          } else if (hitMid) { // If we have seen this before, and we also have seen middle pixels, this is the end of the bush on this row\n            hitRight = true;\n          }\n        } else { // Not a border color\n          if (hitLeft && image.getPixelColor(imgX, imgY) === palette[3]) { // If this is filled with background right now, mark it as middle\n            hitMid = true;\n          }\n          if (hitMid && !hitRight && colorCount < 5) { // Based on the variables we set above, if we are in the middle of the image, set the color\n            image.setPixelColor(palette[tileOpt['Bush Color']], imgX, imgY);\n          }\n        }\n      }\n    }\n\n    // Draw small shadow near the foot of the plant\n    for (let shadowX = x - Math.floor(r/2)+1; shadowX < x + r+1; shadowX++) {\n      image.setPixelColor(palette[0], shadowX, y + r + 1);\n      if (shadowX < x + r) {\n        image.setPixelColor(palette[0], shadowX, y + r);\n      }\n    }\n\n    // Pick a few random spots to draw berries/freckles/whatever\n    let freckleCount = 0;\n    // Limit # of tries to make, to prevent infinite loop\n    for (var i = 0; i < 100; i++) {\n\n      // If we've hit the number of freckles we're supposed to, bail out\n      if (freckleCount >= tileOpt['Freckle Count']) {\n        break;\n      }\n\n      // Find a random spot in the image\n      const fx = Math.floor(Math.random() * (image.bitmap.width)),\n        fy = Math.floor(Math.random() * image.bitmap.height);\n\n      // Make sure it's not already a freckle\n      if (image.getPixelColor(fx,fy) === palette[tileOpt['Bush Color']]) {\n        freckleCount++;\n        // Set this pixel\n        image.setPixelColor(palette[tileOpt['Freckle Color']], fx, fy);\n\n        // If it's larger than 1, also fill 1px to the top/left/right/bottom\n        if (tileOpt['Freckle Size'] > 1) {\n          [[fx-1, fy], [fx+1,fy], [fx, fy-1], [fx, fy+1]].forEach(coords => {\n            const fxx = coords[0], fyy = coords[1];\n            if (image.getPixelColor(fxx, fyy) === palette[tileOpt['Bush Color']]) {\n              image.setPixelColor(palette[tileOpt['Freckle Color']], fxx, fyy);\n            }\n          });\n        }\n      }\n    }\n  }\n\n  static async drawRock(image, tileOpt, palette) {\n\n    // We use a quirk of the image library that clamps pixel locations to the inside to make a rock-like shape, \n    // however this forces us to put it at the bottom of the image. Make a copy of the image we can do this on, \n    // which we will later blit onto the original image.\n    const rockImg = await Jimp.read(image);\n\n    // Draw a standard circle outline based on the width of the rock\n    const r = tileOpt['Rock Size'];\n\n    // Purposely place this towards the bottom of the available space in the image.\n    const x = 8, y = rockImg.bitmap.height - (tileOpt['Rock Size'] - 2);\n    let angle, x1, y1;\n    for (var i = 0; i < 360; i++) {\n      angle = i;\n      x1 = r * Math.cos(angle * Math.PI / 180);\n      y1 = r * Math.sin(angle * Math.PI / 180);\n\n      rockImg.setPixelColor(palette[0], Math.round(x + x1), Math.round(y + y1));\n    }\n\n    // terribly simple color filling algorithm - look at \"drawPlant\" to understand this. \n    for (var imgY = 0; imgY < rockImg.bitmap.height; imgY++) {\n      let hitLeft = false, hitMid = false, hitRight = false, colorCount = 0;\n      for (var imgX = 0; imgX < rockImg.bitmap.width; imgX++) {\n        if (rockImg.getPixelColor(imgX, imgY) === palette[0]) {\n          colorCount++;\n          if (!hitLeft) {\n            hitLeft = true;\n          } else if (hitMid) {\n            hitRight = true;\n          }\n        } else {\n          if (hitLeft && rockImg.getPixelColor(imgX, imgY) === palette[3]) {\n            hitMid = true;\n          }\n          if (hitMid && !hitRight && colorCount < 5) { // Must be on the inside of the circle\n            if ((imgX - imgY) < r - Math.floor(r/1.2)) {\n              rockImg.setPixelColor(palette[tileOpt['Rock Color']], imgX, imgY);\n            } else {\n              rockImg.setPixelColor(palette[tileOpt['Rock Highlight Color']], imgX, imgY);\n            }\n          }\n        }\n      }\n    }\n\n    // okay, the image is done, but not really centered, and in a separate image. \n    // Center and blit it back onto our original to finish.\n    await image.blit(rockImg, 0, -1 - Math.floor((image.bitmap.height / 2) - (tileOpt['Rock Size'])));\n  }\n\n  static async drawLava(image, tileOpt, palette) {\n    // We use Sin calculation to get a \"wavy\" sort of look for the lava\n    const frequency = (tileOpt['Frequency'] / 100),\n      offset = tileOpt['Offset'],\n      waveWidth = tileOpt['Wave Width'];\n\n    // Loop over each row\n    for (let y = 0; y < image.bitmap.width; y++) {\n      // Find where the first wave should start on this row\n      let x = Math.sin((frequency * (Math.abs(y-offset) % image.bitmap.width)) ) * Math.floor(image.bitmap.height / 3);\n\n\n      // Increase X by the wave width repeatedly, and mark them with magic pink so we can use this to change colors later\n      while (x < image.bitmap.width) {\n        // Set a dummy color that we will replace later (magic pink)\n        image.setPixelColor(0xff00ffff, x, y);\n        x += waveWidth;\n      }\n\n      // Loop over every x position, incrementing the palette color each time we hit a magic pink-marked pixel from above\n      let currColor = 1;\n      for (x = 0; x < image.bitmap.width; x++) {\n        if (image.getPixelColor(x, y) === 0xff00ffff) {\n          currColor = 1+((currColor + 1) % 3);\n        }\n        image.setPixelColor(palette[currColor], x, y);\n      }\n    }\n  }\n\n  static async drawSand(image, tileOpt, palette) {\n    // We use Sin calculation to get sand waves here. The logic is very similar to drawLava, check that for documentation.\n    const frequency = (tileOpt['Frequency'] / 100),\n      offset = tileOpt['Offset'],\n      waveWidth = tileOpt['Wave Width'];\n    for (let y = 0; y < image.bitmap.width; y++) {\n      let x = Math.sin((frequency * (Math.abs(y-offset) % image.bitmap.width)) ) * Math.floor(image.bitmap.height / 3);\n\n\n      while (x < image.bitmap.width) {\n        // Set a dummy color to replace\n        image.setPixelColor(0xff00ffff, x, y);\n        x += waveWidth;\n      }\n\n      // Repeat iterating over the whole thing, swapping colors\n      let currColor = 2;\n      for (x = 0; x < image.bitmap.width; x++) {\n        if (image.getPixelColor(x, y) === 0xff00ffff) {\n          currColor = 2+((currColor + 1) % 2);\n        }\n        image.setPixelColor(palette[currColor], x, y);\n      }\n    }\n  }\n\n  static async drawBridge(image, tileOpt, palette) {\n    image.scan(0, 0, image.bitmap.width, image.bitmap.height, (x, y) => {\n      // Draw a simple bridge pattern, filling colors accordingly\n      if (x % (tileOpt['Board Width']+1) === 0 || y < tileOpt['Border Width'] || y > (image.bitmap.width - tileOpt['Border Width'] - 1)) {\n        image.setPixelColor(palette[tileOpt['Separator Color']], x, y);\n      } else {\n        image.setPixelColor(palette[tileOpt['Board Color']], x, y);\n      }\n    })\n  }\n\n  static async drawLadder(image, tileOpt, palette) {\n    image.scan(0, 0, image.bitmap.width, image.bitmap.height, (x, y) => {\n      // Draw a simple ladder pattern, filling colors accordingly.\n      if (y % (tileOpt['Step Width']+1) === 0 || x < tileOpt['Border Width'] || x > (image.bitmap.width - tileOpt['Border Width'] - 1)) {\n        image.setPixelColor(palette[tileOpt['Separator Color']], x, y);\n      } else {\n        image.setPixelColor(palette[tileOpt['Step Color']], x, y);\n      }\n    })\n  }\n\n  static async drawStairs(image, tileOpt, palette) {\n    // Loop over the whole image\n    image.scan(0, 0, image.bitmap.width, image.bitmap.height, (x, y) => {\n      // Determine how tall the stairs are at this x coordinate\n      let stepHeight = Math.floor((x-1) / tileOpt['Step Width']) * tileOpt['Step Height'];\n\n      // If this is a step,\n      if (\n        // This is on a step border on the x axis (horizontal)\n        x % (tileOpt['Step Width']+1) === 0 || \n        // This is on a step border on the y axis (vertical)\n        y < tileOpt['Border Width'] +  stepHeight || \n        // This is taller than the step height at this y coordinate\n        y > (image.bitmap.width - tileOpt['Border Width'] - 1)\n      ) {\n        image.setPixelColor(palette[tileOpt['Separator Color']], x, y);\n      } else {\n        image.setPixelColor(palette[tileOpt['Step Color']], x, y);\n      }\n    })\n  }\n\n\n  // Helper function, recreates a jimp image, give the base64 representation we use elsewhere.\n  static async imageFromBase64(thisB64) {\n    thisB64 = thisB64.substr(thisB64.indexOf(',')+1);\n    return await Jimp.read(Buffer.from(thisB64, 'base64'));\n  }\n\n  // Generate all images, and stitch them together into one tilemap image\n  static generateFullSet(imageState) {\n    return new Promise((resolve, reject) =>{\n      // Make an image as big as all of our tiles, plus one \"blank\" tile to start\n      new Jimp(IMAGE_WIDTH * (AVAILABLE_TILE_TYPES.length+1), IMAGE_HEIGHT, 0xffffffff, (err, image) =>{\n        if (err) { reject(err); }\n\n        // Force back into async context\n        (async () => {\n\n          // Loop over each available image type\n          for (let i = 0; i < AVAILABLE_TILE_TYPES.length; i++ ) {\n            // Grab the image we have in storage\n            let thisImg = await this.imageFromBase64(imageState[AVAILABLE_TILE_TYPES[i]]);\n            // Slap it on the image at the right position.\n            await image.blit(thisImg, (i+1)*IMAGE_WIDTH, 0);\n          }\n\n\n          return image.getBase64Async('image/png');\n        })().then(resolve, reject);\n\n      });\n\n\n    });\n  }\n\n  // Draw an image made up of the tiles we created, based on a built-in example map\n  static generateMapPreview(imageState) {\n    const width = Math.sqrt(TILE_PREVIEW_MAP.length);\n    return new Promise((resolve, reject) =>{\n      // Dealing with Jimp's weird promise quirks (again)\n      new Jimp(IMAGE_WIDTH * width, IMAGE_HEIGHT * width, 0xffffffff, (err, image) =>{\n        if (err) { reject(err); }\n\n        // Force back into async context\n        (async () => {\n\n          // Build up a lookup table of jimp-usable images from tile name, since we should use all of em\n          let tileImages = {};\n          let drawState = {};\n          for (let i = 0; i < AVAILABLE_TILE_TYPES.length; i++) {\n            let thisB64 = imageState[AVAILABLE_TILE_TYPES[i]];\n            thisB64 = thisB64.substr(thisB64.indexOf(',')+1);\n            tileImages[AVAILABLE_TILE_TYPES[i]] = await this.imageFromBase64(imageState[AVAILABLE_TILE_TYPES[i]]);\n            drawState[AVAILABLE_TILE_TYPES[i]] = false;\n          }\n\n          // Loop over the given map\n          for (var x = 0; x < width; x++) {\n            for (var y = 0; y < width; y++) {\n              // Draw the given tile at its position.\n              const pos = y*width + x;\n              image.blit(tileImages[TILE_PREVIEW_MAP[pos]], x * IMAGE_WIDTH, y * IMAGE_HEIGHT);\n\n              // Track which tiles have been drawn, so we can print a warning if we miss one\n              drawState[TILE_PREVIEW_MAP[pos]] = true;\n            }\n          }\n\n          // Check which tiles were not drawn, print a warning.\n          const notDrawn = AVAILABLE_TILE_TYPES.filter(a => !drawState[a]);\n          if (notDrawn.length > 0) {\n            console.warn('Some tiles were not included in the preview!', notDrawn.join(', '));\n          }\n\n          return image.getBase64Async('image/png');\n        })().then(resolve, reject);\n\n      });\n\n    });\n\n  }\n\n  // This outputs a pattern table usable with the ENS directly, or NES art tools like nesst/nexxt\n  static async generateNesPatternTables(imageState, tileProps, organizeIntoBlocks) {\n    let ppuData = [\n    ];\n\n    // Loop over every tile, and convert it to NES binary format\n    for (var i = 0; i < AVAILABLE_TILE_TYPES.length; i++) {\n      const tileType = AVAILABLE_TILE_TYPES[i],\n        tile = await this.imageFromBase64(imageState[tileType]),\n        tileColorData = new Array(tile.bitmap.width * tile.bitmap.height),\n        paletteColors = paletteData[tileProps[tileType].Palette];\n\n      // Loop over all pixels in this tile, and grab the color\n      tile.scan(0, 0, tile.bitmap.width, tile.bitmap.height, (x, y) => {\n        const color = tile.getPixelColor(x, y);\n        // Then drop the 2-bit value of the color into our array, for later use.\n        tileColorData[x + (y * tile.bitmap.width)] = paletteColors.indexOf(color);\n      });\n\n      // Separate out the two bit values we care about for each pixel, allowing us to build bitplanes\n      let bits0 = tileColorData.map (x => x & 0x01),\n        bits1 = tileColorData.map(x => (x & 0x02) >> 1);\n      \n      // This is kind of gross and confusing. It's basically forcing this: https://wiki.nesdev.com/w/index.php?title=PPU_pattern_tables\n      // Build up two bitplanes for each tile, then, pixel-by-pixel, build them up and reassemble.\n\n      // First build up multiple bitplanes, a left and a right for each 8x8 pixel tile in this thing. tl, tr, bl, br\n      let thisTileBp1a = [], thisTileBp2a = [], thisTileBp1b = [], thisTileBp2b = [],\n        thisTileBp3a = [], thisTileBp3b = [], thisTileBp4a = [], thisTileBp4b = [];\n      \n      // Loop over each of the 4 bitplanes (this feels weird because it is)\n      for (let bitplaneNum = 0; bitplaneNum < 4; bitplaneNum++) {\n\n        // Loop over each row in this tile/bitplane\n        for (let j = 0; j < 8; j++) {\n\n          // In our first pass, add a 0 to all planes, so we can do math to them\n          if (bitplaneNum === 0) {\n            thisTileBp1a.push(0);\n            thisTileBp2a.push(0);\n            thisTileBp3a.push(0);\n            thisTileBp4a.push(0);\n            thisTileBp1b.push(0);\n            thisTileBp2b.push(0);\n            thisTileBp3b.push(0);\n            thisTileBp4b.push(0);\n          }\n\n          // Loop over every pixel in the row, assembling each pixel into its left and right bit\n          for (let k = 0; k < 8; k++) {\n            if (bitplaneNum === 0) {\n              thisTileBp1a[j] += bits0[(j * tile.bitmap.width) + k] << (7 - k);\n              thisTileBp1b[j] += bits1[(j * tile.bitmap.width) + k] << (7 - k);\n            } else if (bitplaneNum === 1) {\n              thisTileBp2a[j] += bits0[(j * tile.bitmap.width) + k + 8] << (7 - k);\n              thisTileBp2b[j] += bits1[(j * tile.bitmap.width) + k + 8] << (7 - k);\n            } else if (bitplaneNum === 2) {\n              thisTileBp3a[j] += bits0[(j * tile.bitmap.width) + k + 128] << (7 - k);\n              thisTileBp3b[j] += bits1[(j * tile.bitmap.width) + k + 128] << (7 - k);\n            } else {\n              thisTileBp4a[j] += bits0[(j * tile.bitmap.width) + k + 128 + 8] << (7 - k);\n              thisTileBp4b[j] += bits1[(j * tile.bitmap.width) + k + 128 + 8] << (7 - k);\n            }\n          }\n        }\n      }\n\n      // Add each bitplane to the tile, in the correct order. \n      // At this point, we just put all the tiles in order, so you'll get top left, top right, bottom left, bottom right all in a row\n      ppuData = [\n        ...ppuData,\n        ...thisTileBp1a,\n        ...thisTileBp1b,\n        ...thisTileBp2a,\n        ...thisTileBp2b,\n        ...thisTileBp3a,\n        ...thisTileBp3b,\n        ...thisTileBp4a,\n        ...thisTileBp4b\n      ];\n    }\n    \n    // Prepend a blank tile, with nothing in it - 64 bytes (4 16 byte 8px tiles)\n    ppuData = [\n      0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0,\n      ...ppuData\n    ]\n\n    // The data is currently in a linear format, where each (16 byte) block is in sequence\n    // not pretty, but easy to work with in some games. If the user wants that, sweet!\n    if (!organizeIntoBlocks) {\n      return new Uint8Array(ppuData);\n    }\n\n    // Okay, we have a little work to do to organize it. NES chr files are 16 by 16, 8px tiles, where each tile \n    // takes up 16 bytes. We have to break up by tile. Note we have to add the extra tile from above into the count.\n    \n    // Build up a new array - we just supply a full 4kb pattern table to make this simple for ourselves.\n    let organizedArray = new Array(4096).fill(0);\n    \n    // loop over all tiles (including our blank one)\n    for (let i = 0; i < AVAILABLE_TILE_TYPES.length+1; i++) {\n\n      // Determine where this tile will fall in our organized map - 2 8x8 tiles on one row, two 8x8 tiles on the next.\n      const x = i % 8,\n        y = Math.floor(i / 8),\n        // Get our position within this new map\n        position = (16/*tile size (bytes)*/ * 16/*row width, in nes tiles*/ * 2/*rows per metatile*/ * y) + (16 * x * 2),\n        // Find the position in the original array\n        originalPosition = (i * 4) * 16;\n\n      // Copy the top 32 bytes (2 tiles) into their new home\n      for (let j = 0; j < 32; j++) {\n        organizedArray[position+j] = ppuData[originalPosition+j];\n      }\n      // Copy the bottom 32 bytes into their new home as well)\n      for (let j = 0; j < 32; j++) {\n        organizedArray[position + (16/* tile size (bytes)*/ * 16 /*row width*/) + j] = ppuData[originalPosition + j + 32];\n      }\n    }\n\n    // Okay, we're finally done!\n    return new Uint8Array(organizedArray);\n\n  }\n}"],"sourceRoot":""}