{"version":3,"sources":["constants/tile-constants.js","components/download-dropdown.js","constants/palette-constants.js","components/palette-color-preview.js","components/palette-preview.js","components/tile-setting.js","components/tiled-image.js","components/map-preview-button.js","App.js","reportWebVitals.js","index.js","services/image-generator.js"],"names":["IMAGE_WIDTH","IMAGE_HEIGHT","AVAILABLE_TILE_TYPES","DEFAULT_TILE_TYPE","TILE_BACKGROUND_COLORS","grass","water","lava","rock","brick","hole","plant","block","sand","bridge","ladder","stairs","tile","door","lockdoor","TILE_NAMES","TILE_PREVIEW_IDS","TILE_OPTIONS","name","type","defaultValue","min","max","disabled","step","TILE_PREVIEW_MAP","TextDecoder","MapPreviewButton","React","Component","constructor","props","super","this","state","forceDownload","data","a","document","createElement","href","download","click","img","ImageGenerator","generateFullSet","tileImages","organizeIntoBlocks","generateNesPatternTables","tileProps","b64data","Buffer","from","toString","Uint8Array","nesPaletteData","render","_jsx","children","_jsxs","SlDropdown","SlButton","caret","slot","SlMenu","SlMenuItem","title","onClick","downloadAll","downloadBin","downloadPalette","availablePalettes","paletteData","getPalette","idOrName","PaletteColorPreview","className","style","backgroundColor","color","PalettePreview","palette","map","padStart","TileSetting","setting","tileTypeId","updateTileState","reloadFromProps","UNSAFE_componentWillReceiveProps","nextProps","setState","b","c","SlRange","label","value","onSlChange","e","target","SlRadioGroup","n","SlRadio","checked","SlSelect","replace","SlOption","console","error","concat","TiledImage","allSrc","tileId","id","src","i","alt","imageRef","createRef","mapImage","_this$imageRef","_this$imageRef$curren","generateMapPreview","current","show","SlTooltip","content","showDialog","SlDialog","ref","setBasePath","App","tileType","currentTileImg","builtTileImages","forEach","t","opt","undefined","val","Math","floor","random","lastTileType","localStorage","getItem","info","length","generateTileImage","reloadImage","reRandomize","newState","force","arguments","Palette","res","generateImage","getCurrentTileImage","updateTileType","event","setItem","typeName","DownloadDropdown","process","reportWebVitals","onPerfEntry","Function","then","_ref","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","getElementById","modulus","getRandomImageCoords","image","x","bitmap","width","y","height","tileOpt","Promise","resolve","reject","Jimp","async","err","drawGrass","drawWater","drawBrick","drawBlock","drawHole","drawPlant","drawRock","drawLava","drawSand","drawBridge","drawLadder","drawStairs","drawDoor","drawLockedDoor","warn","getBase64Async","setPixelColor","originX","originY","depthR","scan","idx","dx","dy","xDiff","yDiff","row1Lines","row2Lines","push","rowNum","indexOf","tileSize","h","borderWidth","fuzzWidth","r","angle","x1","y1","cos","PI","sin","round","imgY","hitLeft","hitMid","hitRight","colorCount","imgX","getPixelColor","shadowX","freckleCount","fx","fy","coords","fxx","fyy","rockImg","read","blit","frequency","offset","waveWidth","abs","currColor","drawBaseDoor","knobY","knobX","lockY","lockX","stepHeight","thisB64","substr","imageState","thisImg","imageFromBase64","sqrt","drawState","pos","notDrawn","filter","join","ppuData","tileColorData","Array","paletteColors","bits0","bits1","thisTileBp1a","thisTileBp2a","thisTileBp1b","thisTileBp2b","thisTileBp3a","thisTileBp3b","thisTileBp4a","thisTileBp4b","bitplaneNum","j","k","organizedArray","fill","position","originalPosition"],"mappings":"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","file":"static/js/main.fe7ae9c1.chunk.js","sourcesContent":["export const IMAGE_WIDTH = 16;\nexport const IMAGE_HEIGHT = 16;\n\nexport const AVAILABLE_TILE_TYPES = [\n  'block',\n  'brick',\n  'bridge', \n  'plant', // Aka \"bush\"\n  'door',\n  'grass', \n  'hole',\n  'ladder',\n  'lava',\n  'lockdoor', \n  'rock', \n  'sand',\n  'stairs',\n  'tile',\n  'water',\n];\n\nexport const DEFAULT_TILE_TYPE = 'block';\n\nexport const TILE_BACKGROUND_COLORS = {\n  grass: 3,\n  water: 2,\n  lava: 3,\n  rock: 3, \n  brick: 2,\n  hole: 0,\n  plant: 3,\n  block: 3,\n  sand: 0,\n  bridge: 0,\n  ladder: 0,\n  stairs: 0,\n  tile: 3,\n  door: 3,\n  lockdoor: 3\n};\n\nexport const TILE_NAMES = {\n  grass: 'Grass',\n  water: 'Water',\n  lava: 'Lava',\n  block: 'Block',\n  brick: 'Brick Wall',\n  rock: 'Rock',\n  hole: 'Hole / Gap',\n  plant: 'Bush',\n  sand: 'Sand',\n  bridge: 'Bridge',\n  ladder: 'Ladder',\n  stairs: 'Stairs',\n  tile: 'Tile',\n  door: 'Door',\n  lockdoor: 'Locked Door'\n}\n\nexport const TILE_PREVIEW_IDS = {\n  grass: [ \n    'grass', 'grass', 'grass', \n    'grass', 'grass', 'grass', \n    'grass', 'grass', 'grass',\n  ],\n  water: [\n    'water', 'water', 'water',\n    'water', 'water', 'water',\n    'water', 'water', 'water',\n  ],\n  lava: [\n    'sand', 'lava', 'lava',\n    'sand', 'lava', 'lava',\n    'sand', 'lava', 'lava',\n  ],\n  block: [\n    'block', 'block', 'block',\n    'block', 'grass', 'grass',\n    'block', 'grass', 'grass',\n  ],\n  brick: [\n    'brick', 'brick', 'brick',\n    'brick', 'brick', 'brick',\n    'grass', 'grass', 'grass', \n  ],\n  rock: [\n    'sand', 'sand', 'sand',\n    'rock', 'rock', 'rock',\n    'sand', 'sand', 'sand',\n  ],\n  hole: [\n    'sand', 'sand', 'sand',\n    'sand', 'hole', 'sand',\n    'sand', 'sand', 'sand',\n  ],\n  plant: [\n    'grass', 'grass', 'grass',\n    'grass', 'plant', 'grass',\n    'grass', 'grass', 'grass',\n  ],\n  sand: [\n    'sand', 'sand', 'sand',\n    'sand', 'sand', 'sand',\n    'sand', 'sand', 'sand',\n  ],\n  bridge: [\n    'water', 'water', 'water',\n    'bridge', 'bridge', 'bridge',\n    'water', 'water', 'water',\n  ],\n  ladder: [\n    'rock', 'ladder', 'rock',\n    'rock', 'ladder', 'rock',\n    'grass', 'grass', 'grass'\n  ],\n  stairs: [\n    'grass', 'grass', 'grass',\n    'grass', 'stairs', 'grass',\n    'grass', 'grass', 'grass',\n  ],\n  tile: [\n    'tile', 'tile', 'tile',\n    'tile', 'tile', 'tile',\n    'tile', 'tile', 'tile',\n  ],\n  door: [\n    'tile', 'tile', 'tile',\n    'brick', 'door', 'brick',\n    'grass', 'grass', 'grass',\n  ],\n  lockdoor: [\n    'tile', 'tile', 'tile',\n    'brick', 'lockdoor', 'brick',\n    'grass', 'grass', 'grass',\n  ]\n}\n\nexport const TILE_OPTIONS = {\n  grass: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Green'},\n    {name: 'Short Blades', min: 0, max: 10, type: 'range', defaultValue: 1},\n    {name: 'Tall Blades', min: 0, max: 10, type: 'range', defaultValue: 0},\n    {name: 'Triangles', min: 0, max: 8, type: 'range', defaultValue: 4}\n  ],\n  water: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Blue'},\n    {name: 'Lines', min: 2, max: 4, type: 'range'},\n    // Couldn't quite get what I wanted out of this - the areas kind of need to be relative to the lines, and \n    // that's a bit more complex than I'd hoped.\n    {name: 'Deeper Areas', min: 0, max: 3, type: 'range', disabled: true, defaultValue: 0}\n  ],\n  lava: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Red'},\n    {name: 'Frequency', min: 15, max: 25, type: 'range' },\n    {name: 'Offset', min: 0, max: 15, type: 'range'},\n    {name: 'Wave Width', min: 4, max: 8, type: 'range'}\n  ],\n  rock: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Yellow'},\n    {name: 'Rock Size', min: 3, max: 7, type: 'range'},\n    {name: 'Rock Color', type: 'color', defaultValue: 2},\n    {name: 'Rock Highlight Color', type: 'color', defaultValue: 3}\n  ],\n  brick: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Red'},\n    {name: 'Brick Width', min: 5, max: 12, type: 'range'},\n    {name: 'Brick Height', min: 2, max: 12, type: 'range'},\n    {name: 'Brick Color', type: 'color', defaultValue: 2}\n  ],\n  block: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Red'},\n    {name: 'Height', min: 4, max: 8, type: 'range'}\n  ],\n  tile: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Red'},\n    {name: 'Height', min: 2, max: 3, type: 'range'}\n  ],\n  hole: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Yellow'},\n    {name: 'Hole Size', min: 6, max: 14, type: 'range', step: 2},\n    {name: 'Fuzz Area', min: 1, max: 2, type: 'range', defaultValue: 1}\n  ],\n  plant: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Green'},\n    {name: 'Bush Size', min: 3, max: 6, type: 'range'},\n    {name: 'Bush Color', type: 'color', defaultValue: 2},\n    {name: 'Freckle Color', type: 'color', defaultValue: 1},\n    {name: 'Freckle Count', min: 2, max: 8, type: 'range'},\n    {name: 'Freckle Size', min: 1, max: 2, type: 'range', defaultValue: 1}\n  ],\n  sand: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Yellow'},\n    {name: 'Frequency', min: 15, max: 75, type: 'range' },\n    {name: 'Offset', min: 0, max: 15, type: 'range'},\n    {name: 'Wave Width', min: 3, max: 12, type: 'range'}\n  ],\n  bridge: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Red'},\n    {name: 'Board Width', min: 3, max: 9, type: 'range', step: 2, defaultValue: 7},\n    {name: 'Border Width', min: 0, max: 2, type: 'range', defaultValue: 1},\n    {name: 'Board Color', type: 'color', defaultValue: 1},\n    {name: 'Separator Color', type: 'color', defaultValue: 0},\n  ],\n  ladder: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Blue'},\n    {name: 'Step Width', min: 3, max: 9, type: 'range', step: 2, defaultValue: 3},\n    {name: 'Border Width', min: 0, max: 2, type: 'range', defaultValue: 1},\n    {name: 'Step Color', type: 'color', defaultValue: 3},\n    {name: 'Separator Color', type: 'color', defaultValue: 1},\n  ],\n  stairs: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Red'},\n    {name: 'Step Width', min: 3, max: 9, type: 'range', step: 2, defaultValue: 7},\n    {name: 'Step Height', min: 1, max: 3, type: 'range'},\n    {name: 'Border Width', min: 0, max: 2, type: 'range', defaultValue: 1},\n    {name: 'Step Color', type: 'color', defaultValue: 1},\n    {name: 'Separator Color', type: 'color', defaultValue: 0},\n  ],\n  door: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Yellow'},\n    {name: 'Panel Width', min: 3, max: 8, type: 'range', step: 1},\n    {name: 'Knob Width', min: 0, max: 2, type: 'range', step: 1, defaultValue: 1},\n    {name: 'Door Color', type: 'color', defaultValue: 3},\n    {name: 'Knob Color', type: 'color', defaultValue: 1}\n  ],\n  lockdoor: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Yellow'},\n    {name: 'Panel Width', min: 4, max: 8, type: 'range', step: 4},\n    {name: 'Lock Width', min: 3, max: 5, type: 'range', step: 2, defaultValue: 5},\n    {name: 'Door Color', type: 'color', defaultValue: 3},\n    {name: 'Lock Color', type: 'color', defaultValue: 1}\n  ]\n\n};\n  \nexport const TILE_PREVIEW_MAP = [\n  'brick', 'brick', 'ladder', 'brick', 'grass', 'grass', 'grass', 'block', 'tile', 'tile', 'tile', 'tile',\n  'grass', 'grass', 'grass', 'grass', 'grass', 'plant', 'plant', 'block', 'tile', 'tile', 'stairs', 'tile',\n  'grass', 'grass', 'plant', 'plant', 'grass', 'plant', 'plant', 'block', 'tile', 'tile', 'tile', 'tile',\n  'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'block', 'lockdoor', 'block', 'door', 'block',\n  'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass',\n  'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass',\n  'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass',\n  'sand' , 'sand' , 'sand' , 'sand' ,  'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass',\n  'water', 'water', 'water', 'sand' , 'sand', 'grass', 'grass', 'grass', 'grass', 'grass', 'lava', 'lava',\n  'water', 'water', 'water', 'sand' , 'sand', 'sand', 'grass', 'grass', 'grass', 'grass', 'lava', 'lava',\n  'bridge', 'bridge', 'bridge', 'sand' , 'sand', 'sand', 'sand', 'hole', 'sand', 'sand', 'lava', 'lava',\n  'water', 'water', 'water', 'sand' , 'rock', 'sand', 'sand', 'hole', 'sand', 'sand', 'lava', 'lava',\n];","import SlDropdown from '@shoelace-style/shoelace/dist/react/dropdown';\nimport SlMenuItem from '@shoelace-style/shoelace/dist/react/menu-item';\nimport SlButton from '@shoelace-style/shoelace/dist/react/button';\nimport SlMenu from '@shoelace-style/shoelace/dist/react/menu';\nimport React from 'react';\n\nimport ImageGenerator from '../services/image-generator';\n\nimport { nesPaletteData } from '../constants/palette-constants';\n\nconst decoder = new TextDecoder('utf8');\n\n// Renders a dropdown with options to downloda all images\n// Props:\n// - tileImages: Collection of images to use for the given ids\n// - tileProps: Collection of properties around tiles, used to get palette\nexport default class MapPreviewButton extends React.Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  forceDownload(data, name) {\n    // Force a download, the new old-fashioned way\n    let a = document.createElement(\"a\");\n    a.href = data; \n    a.download = name;\n    a.click();\n  }\n\n  async downloadAll() {\n    const img = await ImageGenerator.generateFullSet(this.props.tileImages);\n    this.forceDownload(img, 'Tileset.png');\n  }\n\n  async downloadBin(organizeIntoBlocks) {\n    const img = await ImageGenerator.generateNesPatternTables(this.props.tileImages, this.props.tileProps, organizeIntoBlocks);\n    const b64data = 'data:application/octet-stream;base64,' + Buffer.from(img).toString('base64');\n    this.forceDownload(b64data, '2bit-tile-generator.chr');\n  }\n\n  async downloadPalette() {\n    let data = new Uint8Array([\n      ...nesPaletteData['NES Default Blue'], \n      ...nesPaletteData['NES Default Red'], \n      ...nesPaletteData['NES Default Green'], \n      ...nesPaletteData['NES Default Yellow']\n    ]);\n    // To base64 url string\n    const b64data = 'data:application/octet-stream;base64,' + Buffer.from(data).toString('base64');\n    this.forceDownload(b64data, '2bit-tile-generator.pal');\n  }\n\n  render() {\n    return <span>\n      <SlDropdown>\n        <SlButton caret slot=\"trigger\">Download</SlButton>\n        <SlMenu>\n          <SlMenuItem title=\"Download a single png file with all tiles\" onClick={() => this.downloadAll()}>Download Tile Strip (.png)</SlMenuItem>\n          <SlMenuItem title=\"Download NES binary data, with tile data organized linearly (for games, nesst, etc)\" onClick={() => this.downloadBin(false)}>Download linear binary format (.chr)</SlMenuItem>\n          <SlMenuItem title=\"Download NES binary data, with all tiles organized visually into 16x16 tiles (for games, nesst, etc)\" onClick={() => this.downloadBin(true)}>Download organized binary format (.chr)</SlMenuItem>\n          <SlMenuItem title=\"Download Default NES Palette file (games, nesst, etc)\" onClick={() => this.downloadPalette()}>Download binary palette (.pal)</SlMenuItem>\n        </SlMenu>\n      </SlDropdown>\n    </span>;\n    \n  }\n}","export const availablePalettes = [\n    'Gameboy',\n    'NES Default Red',\n    'NES Default Blue',\n    'NES Default Green',\n    'NES Default Yellow'\n];\n\nexport const paletteData = {\n    // NOTE: These colors are exact matches that gbtd understands. Don't change just to make pretty!\n    // (or at least make a separate palette)\n    'Gameboy': [0x000000ff, 0x808080ff, 0xc0c0c0ff, 0xffffffff],\n    'NES Default Blue': [0x000000ff, 0x00008fff, 0x4488ffff, 0x99ccffff],\n    'NES Default Red': [0x000000ff, 0x550000ff, 0x993300ff, 0xdd6644ff],\n    'NES Default Green': [0x000000ff, 0x113300ff, 0x336600ff, 0x77bb00ff],\n    'NES Default Yellow': [0x000000ff, 0x666600ff, 0xbbaa00ff, 0xeedd88ff]\n}\n\n// Used to build up an actual NES palette, for download\nexport const nesPaletteData = {\n    'Gameboy': [0x0f, 0x00, 0x10, 0x30],\n    'NES Default Blue': [0x0f, 0x01, 0x21, 0x31],\n    'NES Default Red': [0x0f, 0x06, 0x16, 0x26],\n    'NES Default Green': [0x0f, 0x09, 0x19, 0x29],\n    'NES Default Yellow': [0x0f, 0x08, 0x18, 0x28]\n}\n\nexport const getPalette = (idOrName) => {\n    if (typeof idOrName === 'string') {\n        return paletteData[idOrName];\n    } else {\n        return paletteData[availablePalettes[idOrName]];\n    }\n}","import React from 'react';\nimport './palette-color-preview.css';\n\n// Given a hex color, create a component with that as the background color\n// props: \n// - color: A hex color in rgba format -including alpha. Example: 0xff00ffff\nexport default class PaletteColorPreview extends React.Component {\n\n  render() {\n    return <div className=\"palette-color-preview\" style={{backgroundColor: '#' + this.props.color}}></div>;\n  }\n}","import React from 'react';\nimport './palette-preview.css';\n\nimport PaletteColorPreview from './palette-color-preview';\n\n// Given an array of colors in rgba hex numeral format, draw the palette as dom elements.\n// Props:\n// - palette: An array of colors, in hex format, including alpha. eg 0xff00ffff\nexport default class PalettePreview extends React.Component {\n  render() {\n    return <div className=\"palette-preview\">\n      {this.props.palette.map(a => <PaletteColorPreview key={'prev-' + a} color={a.toString(16).padStart(8, '0')}></PaletteColorPreview>)}\n    </div>;\n  }\n}","import React from 'react';\nimport './tile-setting.css';\n\nimport SlRadio from '@shoelace-style/shoelace/dist/react/radio';\nimport SlRadioGroup from '@shoelace-style/shoelace/dist/react/radio-group';\nimport SlRange from '@shoelace-style/shoelace/dist/react/range';\nimport SlSelect from '@shoelace-style/shoelace/dist/react/select';\nimport SlOption from '@shoelace-style/shoelace/dist/react/option';\n\nimport { availablePalettes, getPalette } from '../constants/palette-constants';\n\nimport PaletteColorPreview from './palette-color-preview';\nimport PalettePreview from './palette-preview';\n\n// Given a setting property (such as those defined in tile-constants), render it as a configurable setting.\n// Available types are: range, color, and palette\n// props: \n// - setting: The settings object from constants. Keys detailed there\n// - state: The application state surrounding this thing. This is kind of clunky, and a workaround for redux!\n// - tileTypeId: A 'type' of tile, the key for the settings object.\nexport default class TileSetting extends React.Component {\n  setting = null;\n  state = null;\n  tileTypeId = null;\n  updateTileState = () => {};\n  constructor(props) {\n    super(props);\n    this.state = props.state;\n    this.reloadFromProps(props);\n  }\n\n  // Make sure this component always refreshes when props change.\n  // NOTE: We would be far better served by a redux pattern here, but that's more effort than I'd care\n  // to put in at this stage. At some point we might want to migrate to something better.\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    this.reloadFromProps(nextProps);\n    this.setState(nextProps.state);\n  }\n\n  reloadFromProps(props) {\n    this.setting = props.setting;\n    this.tileTypeId = props.tileTypeId;\n    this.updateTileState = (a, b, c) => {\n        props.updateTileState(a, b, c);\n    };\n  }\n\n  render() {\n    const setting = this.setting;\n\n    if (setting.disabled || setting === null) { return <span key={\"disabled-setting-\" + setting.type + setting.name}></span>; }\n    switch (setting.type) {\n      case 'range':\n        // This could probably be a component of its\n        return <div className=\"tile-option\" key={\"range-\" + setting.type + setting.name}>\n            <SlRange key={this.tileTypeId + setting.name} \n              min={setting.min} \n              max={setting.max} \n              step={setting.step || 1} \n              label={setting.name} \n              value={this.state.tileProps[this.tileTypeId][setting.name]} \n              onSlChange={e => this.updateTileState(this.tileTypeId, setting.name, e.target.value)}>\n            </SlRange>\n            <div className=\"below-range\">\n              <small className=\"left\">{setting.min}</small>\n              <small className=\"mid\">Current: {this.state.tileProps[this.tileTypeId][setting.name]}</small>\n              <small className=\"right\">{setting.max}</small>\n            </div>\n          </div>;\n      case 'color':\n        return <div className=\"tile-option\" key={\"palette-\" + setting.type + setting.name}>\n          <SlRadioGroup label={setting.name}>\n            {[0, 1, 2, 3].map(n => {\n              return <SlRadio \n                  value={n} \n                  checked={this.state.tileProps[this.tileTypeId][setting.name] === n ? true : false} \n                  key={\"palette-color\" + setting.type + setting.name + '-' + n} \n                  onSlChange={e => e.target.checked ? this.updateTileState(this.tileTypeId, setting.name, n) : null}\n                >\n                  Color {n+1} \n                  <PaletteColorPreview color={getPalette(this.state.tileProps[this.tileTypeId]['Palette'])[n].toString(16).padStart(8, '0')}></PaletteColorPreview>\n                </SlRadio>\n            })}\n          </SlRadioGroup>\n        </div>\n      case 'palette':\n        return <div className=\"tile-option\" key={'palette-' + setting.type + setting.name}>\n          <SlSelect \n            label=\"Palette Color\" \n            value={this.state.tileProps[this.tileTypeId][setting.name].replace(/ /g, '_')}\n            onSlChange={e => this.updateTileState(this.tileTypeId, setting.name, e.target.value.replace(/_/g, ' '))}>\n              {availablePalettes.map(a => <SlOption key={a} value={a.replace(/ /g, '_')}>{a} <PalettePreview palette={getPalette(a)}></PalettePreview></SlOption>)}\n          </SlSelect>\n        </div>\n      default:\n        console.error(`Unknown tile option type \"${setting.type}\" found!`, setting);\n        return <span></span>;\n    }\n\n  }\n}","import React from 'react';\nimport './tiled-image.css';\n\nimport { TILE_PREVIEW_IDS } from '../constants/tile-constants';\n\n// Renders an image in a tiled pattern, sizeXsize wide\n// Props:\n// - tileId: The id of the tile to render, looked up from constants\n// - tileImages: Collection of images to use for the given ids\nexport default class TiledImage extends React.Component {\n  render() {\n    const allSrc = TILE_PREVIEW_IDS[this.props.tileId].map(id => this.props.tileImages[id]);\n    return <div className=\"tile-preview-collection\">\n      {allSrc.map((src, i) => <img alt=\"\" src={src} key={'preview-' + i}></img>)}\n    </div>\n  }\n}","import SlButton from '@shoelace-style/shoelace/dist/react/button';\nimport SlDialog from '@shoelace-style/shoelace/dist/react/dialog';\nimport SlTooltip from '@shoelace-style/shoelace/dist/react/tooltip';\nimport React from 'react';\n\nimport ImageGenerator from '../services/image-generator';\n\nimport './map-preview-button.css';\n\n// Renders a preview map with the given images. simulates a simple game map\n// Props:\n// - tileImages: Collection of images to use for the given ids\nexport default class MapPreviewButton extends React.Component {\n\n  constructor(props) {\n    super(props);\n    this.imageRef = React.createRef();\n    this.state = {mapImage: null};\n  }\n\n  async showDialog() {\n    const img = await ImageGenerator.generateMapPreview(this.props.tileImages);\n    this.setState({mapImage: img});\n    // This should always be set - I used the ? to avoid issues with some hacky test code I wrote\n    this.imageRef?.current?.show();\n  }\n\n\n  render() {\n    return <span>\n      <SlTooltip content=\"Show a preview image using all of the tiles\">\n        <SlButton onClick={() => this.showDialog()}>Preview as map</SlButton>\n      </SlTooltip>\n      <SlDialog label=\"Map Preview\" ref={this.imageRef} className=\"map-preview-dialog\">\n        <img alt=\"Map Preview\" src={this.state.mapImage}></img>\n      </SlDialog>\n    </span>;\n    \n  }\n}","import React from 'react';\n\n// Shoelace components\nimport '@shoelace-style/shoelace/dist/themes/light.css';\nimport SlButton from '@shoelace-style/shoelace/dist/react/button';\nimport SlSelect from '@shoelace-style/shoelace/dist/react/select';\nimport SlOption from '@shoelace-style/shoelace/dist/react/option';\nimport SlTooltip from '@shoelace-style/shoelace/dist/react/tooltip';\n\n// Services\nimport ImageGenerator from './services/image-generator';\n\n// Custom components\nimport TileSetting from './components/tile-setting';\nimport TiledImage from './components/tiled-image';\nimport MapPreviewButton from './components/map-preview-button';\nimport DownloadDropdown from './components/download-dropdown';\n\n// Constants\nimport { TILE_NAMES, TILE_OPTIONS, AVAILABLE_TILE_TYPES, DEFAULT_TILE_TYPE } from './constants/tile-constants';\nimport { getPalette } from './constants/palette-constants';\n\nimport { setBasePath } from '@shoelace-style/shoelace/dist/utilities/base-path';\nsetBasePath('https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/')\n\nimport './App.css';\n// Huge app component that could probably be broken down well if I got smart with a Store for state\nclass App extends React.Component {\n\n  // Initializer, mostly sets up initial state of the application\n  constructor(props) {\n    super(props);\n    this.state = {\n      tileType: DEFAULT_TILE_TYPE,\n      tileProps: {},\n      // Default palette, if one is not provided via options.\n      palette: getPalette(0),\n      // Transparent 1px gif so we don't show a broken image\n      currentTileImg: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',\n      builtTileImages: {}\n    }\n\n    // NOTE: This logic is almost-duplicated in the reRandomize method\n    AVAILABLE_TILE_TYPES.forEach(t => {\n\n      // Seriously, it's a constructor. The react docs do this. Calm down, eslint.\n      // eslint-disable-next-line\n      this.state.tileProps[t] = {};\n\n      TILE_OPTIONS[t].forEach(opt => {\n        if (opt.defaultValue !== undefined) {\n          // eslint-disable-next-line\n          this.state.tileProps[t][opt.name] = opt.defaultValue;\n        } else if (opt.min !== undefined && opt.max !== undefined) {\n          let val = Math.floor(Math.random() * (opt.max - opt.min +1)) + opt.min;\n\n          // Enforce the step size in randomization\n          if (opt.step) { \n            val -= (val % opt.step); \n          }\n          // es-lint-disable-next-line\n          this.state.tileProps[t][opt.name] = val;\n        }\n      });\n      this.state.builtTileImages[t] = null;\n    });\n\n\n    // Try to retrieve the last tile you were using to restore state\n    try {\n      const lastTileType = localStorage.getItem('2bit-tile-generator__tileType');\n      if (lastTileType !== null) {\n        this.state.tileType = lastTileType;\n      }\n    } catch (e) {\n      console.info('Failed getting information from localStorage, sticking to default', e);\n    }\n  }\n\n  // Generate the images as soon as this is rendered (else we'll call setState too early)\n  async componentDidMount() {\n    for (let i = 0; i < AVAILABLE_TILE_TYPES.length; i++) {\n      await this.generateTileImage(AVAILABLE_TILE_TYPES[i], false);\n    }\n\n    this.reloadImage();\n  }\n\n  // NOTE: This logic is almost-duplicated in the constructor, with defaults and without the disabled check.\n  reRandomize() {\n    let newState = {tileProps: {...this.state.tileProps}};\n    AVAILABLE_TILE_TYPES.forEach(t => {\n      newState.tileProps[t] = {...this.state.tileProps[t]};\n      TILE_OPTIONS[t].forEach(opt => {\n        if (!opt.disabled) {\n          if (opt.min !== undefined && opt.max !== undefined) {\n            let val = Math.floor(Math.random() * (opt.max - opt.min + 1)) + opt.min;\n\n            // Enforce the step sizein randomization\n            if (opt.step) { \n              val -= (val % opt.step); \n            }\n\n            newState.tileProps[t][opt.name] = val;\n          }\n        }\n      });\n    });\n    this.setState(newState, this.reloadImage);\n  };\n\n  async generateTileImage(tileType, force = false) {\n    let palette = this.state.palette;\n    if (this.state.tileProps[tileType].Palette) {\n      palette = getPalette(this.state.tileProps[tileType].Palette);\n    }\n    if (this.state.builtTileImages[tileType] === null || force) {\n      let res = await ImageGenerator.generateImage(tileType, this.state.tileProps[tileType], palette);\n      this.setState({builtTileImages: {\n        ...this.state.builtTileImages,\n        [tileType]: res\n      }});\n      return res;\n    }\n    return this.state.builtTileImages[tileType];\n\n  }\n\n  // Redraw the image based on current state.\n  async getCurrentTileImage(force = false) {\n    return await this.generateTileImage(this.state.tileType, force);\n  }\n\n  // Rebuild the image shown on the page from available settings.\n  async reloadImage(force = true) {\n    this.setState({currentTileImg: await this.getCurrentTileImage(force)});\n  }\n\n  // Helper function to do exactly what it says. Regenerates the image when it's done.\n  updateTileType(event) {\n    this.setState({tileType: event.target.value}, () => this.reloadImage(false));\n    localStorage.setItem('2bit-tile-generator__tileType', event.target.value);\n  }\n\n  // Helper to update state values from the various components that we support.\n  updateTileState(typeName, name, value) {\n    // Test to make sure the value changed to avoid infinite loops from radio buttons triggering this repeatedly\n    if (this.state.tileProps[typeName][name] === value) { \n      return;\n    }\n\n    // React will stomp any nested objects when you use this, so we have to bring in the old state\n    this.setState({\n      tileProps: {\n        ...this.state.tileProps,\n        [typeName]: {\n          ...this.state.tileProps[typeName],\n          [name]: value\n        }\n      }\n    }, this.reloadImage);\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <h1>2Bit Tile Generator</h1>\n        </header>\n        <section>\n\n          <div className=\"control-bar\">\n            <MapPreviewButton tileImages={this.state.builtTileImages}></MapPreviewButton>\n            <DownloadDropdown tileImages={this.state.builtTileImages} tileProps={this.state.tileProps}></DownloadDropdown>\n\n            <SlTooltip content=\"Randomize the settings for all tiles.\">\n              <SlButton onClick={() => this.reRandomize()}>Randomize Settings</SlButton>\n            </SlTooltip>\n            <SlTooltip content=\"Regenerate tile image with the current settings\">\n              <SlButton onClick={() => this.reloadImage(true)}>Regenerate</SlButton>\n            </SlTooltip>\n          </div>\n\n          <div className=\"configurator\">\n            <div className=\"left\">\n              <h3>Tile Preview</h3>\n\n              <h4>Single</h4>\n              <img className=\"tile-preview\" alt=\"Tile Preview\" src={this.state.currentTileImg}></img>\n              <h4>Tiled</h4>\n              <TiledImage tileId={this.state.tileType} tileImages={this.state.builtTileImages}></TiledImage>\n              <div className=\"dl-bar\">\n                <SlButton href={this.state.currentTileImg} download={this.state.tileType + '.png'}>Download</SlButton>\n              </div>\n            </div>\n            <div className=\"right\">\n              <h3>Tile Configuration</h3>\n              <div className=\"tile-option\">\n                <SlSelect label=\"Tile Type\" value={this.state.tileType} onSlChange={e => this.updateTileType(e)} className=\"tile-type-select\">\n                  {AVAILABLE_TILE_TYPES.map(a => <SlOption key={a} value={a}>{TILE_NAMES[a]} <img alt=\"\" slot=\"suffix\" src={this.state.builtTileImages[a]}></img> </SlOption>)}\n                </SlSelect>\n              </div>\n\n              {TILE_OPTIONS[this.state.tileType].map(setting => \n                <TileSetting \n                  key={this.state.tileType + setting.name}\n                  setting={setting} \n                  state={this.state} \n                  tileTypeId={this.state.tileType} \n                  updateTileState={(a, b, c) => this.updateTileState(a, b, c)\n                }></TileSetting>\n              )}\n            </div>\n          </div>\n        </section>\n        <footer>\n          <p>\n            Heavily inspired by <a href=\"https://0x72.itch.io/2bitcharactergenerator\" target=\"_blank\">0x72's 2BitCharactersGenerator</a>. \n            UI powered by <a href=\"https://shoelace.style/\" target=\"_blank\">Shoelace</a>.\n          </p>\n\n          <p>\n            All images generated by this tool are free for use. (CC0) Tool available under the MIT license. (\n            <a href=\"https://gh.nes.science/2bit-tile-generator\" target=\"_blank\">Source</a> • {' '}\n            <a href=\"https://gh.nes.science/2bit-tile-generator/issues\" target=\"_blank\">Feature Requests</a>) \n            </p>\n          <p>Wanna see the other stuff I do? Check out <a href=\"https://nes.science\" target=\"_blank\">nes.science</a>.</p>\n          <SlTooltip content=\"Click for changelog\">\n            <a className=\"version\" href=\"https://gh.nes.science/2bit-tile-generator/blob/main/CHANGELOG.md\" target=\"_blank\">version {process.env.REACT_APP_VERSION}</a>\n          </SlTooltip>\n        </footer>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","import Jimp from 'jimp/es';\nimport { paletteData } from '../constants/palette-constants';\n\nimport { TILE_BACKGROUND_COLORS, IMAGE_WIDTH, IMAGE_HEIGHT, AVAILABLE_TILE_TYPES, TILE_PREVIEW_MAP } from '../constants/tile-constants';\n\n// Because js treats % as a remainder instead of modulus... because, sigh, programming languages were a mistake.\nfunction modulus(a, b) {\n  return ((a % b ) + b) % b;\n}\n\n// Helper to find a random position within the image\nfunction getRandomImageCoords(image) {\n  let x = Math.floor(Math.random() * image.bitmap.width);\n  let y = Math.floor(Math.random() * image.bitmap.height);\n\n  return {x, y};\n}\n\n\n/**\n * Image generation logic. Used to generate all of the various images using Jimp.\n * Define available image types in the constants in ../tile-constants\n * \n * Jimp doesn't have any primitive drawing ability, and I can't find a library to do it. Maybe I'll make one by myself, but until\n * such a time, things are done manually here. (and very, very clumsily)\n */\nexport default class ImageGenerator {\n  // Really just a home for static methods for now. Don't even construct it.\n\n  static generateImage(tileType, tileOpt, palette) {\n    // Jimp isn't super promise friendly - technically it works but it's pretty sketchy at times. Wrap this instead.\n    return new Promise((resolve, reject) =>{\n      new Jimp(IMAGE_WIDTH, IMAGE_HEIGHT, palette[TILE_BACKGROUND_COLORS[tileType]], async (err, image) =>{\n        if (err) { reject(err); }\n\n        // Big, kind of ugly switch statement for each of our available tile types, determining how to draw each one.\n        switch (tileType) {\n          case 'grass': \n          await ImageGenerator.drawGrass(image, tileOpt, palette);\n            break;\n          case 'water':\n            await ImageGenerator.drawWater(image, tileOpt, palette);\n            break;\n          case 'brick':\n            await ImageGenerator.drawBrick(image, tileOpt, palette);\n            break;\n          case 'tile':\n          case 'block':\n            await ImageGenerator.drawBlock(image, tileOpt, palette);\n            break;\n          case 'hole':\n            await ImageGenerator.drawHole(image, tileOpt, palette);\n            break;\n          case 'plant':\n            await ImageGenerator.drawPlant(image, tileOpt, palette);\n            break;\n          case 'rock':\n            await ImageGenerator.drawRock(image, tileOpt, palette);\n            break;\n          case 'lava':\n            await ImageGenerator.drawLava(image, tileOpt, palette);\n            break;\n          case 'sand':\n            await ImageGenerator.drawSand(image, tileOpt, palette);\n            break;\n          case 'bridge':\n            await ImageGenerator.drawBridge(image, tileOpt, palette);\n            break;\n          case 'ladder':\n            await ImageGenerator.drawLadder(image, tileOpt, palette);\n            break;\n          case 'stairs':\n            await ImageGenerator.drawStairs(image, tileOpt, palette);\n            break;\n          case 'door':\n            await ImageGenerator.drawDoor(image, tileOpt, palette);\n            break;\n          case 'lockdoor':\n            await ImageGenerator.drawLockedDoor(image, tileOpt, palette);\n            break;\n          default: \n            console.warn('Unimplemented tile type given!', tileType, 'blank image ahoy');\n        }\n\n        image.getBase64Async('image/png').then(resolve, reject);\n      });\n\n\n    });\n  }\n\n  static drawGrass(image, tileOpt, palette) {\n    for (let i = 0; i < tileOpt['Short Blades']; i++) {\n      const {x, y} = getRandomImageCoords(image);\n      image.setPixelColor(palette[2], x, y);\n    }\n    for (let i = 0; i < tileOpt['Tall Blades']; i++) {\n      const {x, y} = getRandomImageCoords(image);\n      image.setPixelColor(palette[2], x, y);\n      image.setPixelColor(palette[2], x, y === 0 ? (image.bitmap.height - 1) : y-1);\n    }\n\n    for (let i = 0; i < tileOpt['Triangles']; i++) {\n      const {x, y} = getRandomImageCoords(image);\n\n      image.setPixelColor(palette[2], x > 0 ? x-1 : (image.bitmap.width - 1), y);\n      image.setPixelColor(palette[2], x < (image.bitmap.width - 1) ? x+1 : 0, y);\n      image.setPixelColor(palette[2], x, y > 0 ? y-1 : (image.bitmap.height - 1));\n    }\n  }\n\n  static drawWater(image, tileOpt, palette) {\n\n    // Disabled, this didn't end up looking good, tries to fill in deeper areas in a circle around a random point\n    for (let i = 0; i < tileOpt['Deeper Areas']; i++) {\n      const {x: originX, y: originY} = getRandomImageCoords(image);\n      const depthR = Math.floor(Math.random() * 4) + 3;\n\n      image.scan(0, 0, image.bitmap.width, image.bitmap.height, (x, y, idx) => {\n        const dx = originX - x;\n        const dy = originY - y;\n        if (dx*dx + dy*dy <= (depthR*depthR)) {\n          image.setPixelColor(palette[1], x, y);\n        }\n      });\n    }\n\n    // Draw lines starting from a random spot on the image\n    for (let i = 0; i < tileOpt['Lines']; i++) {\n      // Start position\n      const {x: originX, y: originY} = getRandomImageCoords(image);\n      // Determine which direction this line is facing, left/right and up/down\n      const xDiff = Math.floor(Math.random() * 2) === 1 ? 1 : -1;\n      const yDiff = Math.floor(Math.random() * 2) === 1 ? 1 : -1;\n      let x = originX, y = originY;\n      // Set that first pixel manually\n      image.setPixelColor(palette[3], x, y);\n      x = modulus(x + xDiff, image.bitmap.width);\n      y = modulus(y + yDiff, image.bitmap.height);\n      \n      // Repeat this process until we've gone across the full width of the image\n      while (x !== originX && y !== originY) {\n        image.setPixelColor(palette[3], x, y);\n\n        // Pick whether to shift by x, y, neither or both. (It eventually works out)\n        if (Math.random() > 0.3) {\n          // Modulus loops us back over to 0 when we hit the full width\n          x = modulus(x + xDiff, image.bitmap.width);\n        }\n        if (Math.random() > 0.3) {\n          y = modulus(y + yDiff, image.bitmap.height);\n        }\n\n      }\n      // Set the last pixel that was set up in the while loop\n      image.setPixelColor(palette[3], x, y);\n    }\n\n  }\n\n  static drawBrick(image, tileOpt, palette) {\n    const row1Lines = [];\n    const row2Lines = [];\n    // Find where in each row to put the column lines - we have 2 sets, offset by brick width to provide some variation.\n    for (var i = 0; i < image.bitmap.width; i++) {\n      if (modulus(i+1, tileOpt['Brick Width'] + 1) === 0) {\n        row1Lines.push(i);\n      } else if (modulus(i + 1 + Math.floor(tileOpt['Brick Width'] / 2), tileOpt['Brick Width'] + 1) === 0) {\n        row2Lines.push(i);\n      }\n    }\n\n    let rowNum = 0;\n    image.scan(0, 0, image.bitmap.width, image.bitmap.height, (x, y, idx) => {\n      // Fill with bg color to start\n      image.setPixelColor(palette[tileOpt['Brick Color']], x, y);\n\n      // Color brick with border color if this is a border between bricks\n      if (y % (tileOpt['Brick Height'] + 1) === 0) {\n        image.setPixelColor(palette[0], x, y);\n\n        // If this is the first pixel in this row, up the row number, so we can decide which column to use\n        if (x === 0) { ++rowNum; }\n      }\n\n      // If this matches the X for an active column, draw that too\n      if (rowNum % 2 === 0) {\n        if (row1Lines.indexOf(x) !== -1) {\n          image.setPixelColor(palette[0], x, y);\n        }\n      } else {\n        if (row2Lines.indexOf(x) !== -1) {\n          image.setPixelColor(palette[0], x, y);\n        }\n      }\n    });\n\n  }\n\n  static drawBlock(image, tileOpt, palette) {\n    image.scan(0, 0, image.bitmap.width, image.bitmap.height, (x, y) => {\n      const tileSize = (10 - tileOpt['Height']) * 2;\n\n      // Draw a diagonal line across the image, with darker color on the bottom half to show shading\n      image.setPixelColor(x > (image.bitmap.height - y - 1) ? palette[1] : palette[3], x, y);\n\n      \n      // Draw a line across both diagonals, to show where the edges are\n      // NOTE: This also hides some messiness that might be made with the diagonal line above\n      if (x === y) {\n        image.setPixelColor(palette[2], x, y);\n      } else if (x === (image.bitmap.height - y - 1)) {\n        image.setPixelColor(palette[1], x, y);\n      }\n\n      // This is used to determine the \"height\" of the block, which is really the square in the middle, and how big it is\n      const h = ((image.bitmap.height / 2) - (tileSize / 2));\n      \n      // Draw the variable-sized square in the middle\n      if (x > h && x < (h + tileSize - 1)) {\n        if (y > h && y < (h + tileSize - 1)) {\n          image.setPixelColor(palette[2], x, y);\n        }\n      }\n    });\n  }\n\n  static drawHole(image, tileOpt, palette) {\n    const borderWidth = Math.floor((image.bitmap.width / 2) - (tileOpt['Hole Size'] / 2));\n    // Determine how much space to randomly fill with either bg or hole color\n    const fuzzWidth = tileOpt['Fuzz Area']; \n\n    image.scan(0, 0, image.bitmap.width, image.bitmap.height, (x, y) => {\n      // The image currently has a background color that we want, so now we find what parts need to be recolored to black for the hole\n      \n      // Test to make sure we're within he borders of the whole\n      if (\n        (x < borderWidth || x > (image.bitmap.width - 1 - borderWidth)) ||\n        (y < borderWidth || y > (image.bitmap.height - 1 - borderWidth))\n      ) {\n        \n        // Determine whether we are in the \"fuzzy\" area on the outside of the hole\n        if (\n          (x >= (borderWidth - fuzzWidth) && x < borderWidth && (y > borderWidth && y < (image.bitmap.height - 1 - borderWidth))) ||\n          (x >= (borderWidth + tileOpt['Hole Size']) && x < (borderWidth + tileOpt['Hole Size'] + fuzzWidth) && (y > borderWidth && y < (image.bitmap.height -1 - borderWidth))) ||\n          \n          (y >= (borderWidth - fuzzWidth) && y < borderWidth && (x > borderWidth && x < (image.bitmap.width - 1 - borderWidth))) ||\n          (y >= (borderWidth + tileOpt['Hole Size']) && y < (borderWidth + tileOpt['Hole Size'] + fuzzWidth) && (x > borderWidth && x < (image.bitmap.width -1 - borderWidth)))\n        ) {\n          // We're in the fuzzy area, so bail based on rng, causing this pixel to stay as the background color\n          if (Math.random() > 0.35) { return; }\n        }\n        // If you get here, set the background color to black, the hole color.\n        image.setPixelColor(palette[2], x, y);\n      }\n    });\n\n  }\n\n  static drawPlant(image, tileOpt, palette) {\n\n    // Draw a circle around the outside\n    const r = tileOpt['Bush Size'];\n    const x = 8, y = 10 - Math.floor(tileOpt['Bush Size'] / 2);\n    \n    let angle, x1, y1;\n    for (var i = 0; i < 360; i++) {\n      angle = i;\n      x1 = r * Math.cos(angle * Math.PI / 180);\n      y1 = r * Math.sin(angle * Math.PI / 180);\n\n      image.setPixelColor(palette[0], Math.round(x + x1), Math.round(y + y1));\n    }\n\n    // Loop over the whole image, row by row,\n    for (var imgY = 0; imgY < image.bitmap.height; imgY++) {\n      // Track whether, in this row, we have hit the first border, a pixel of filling, and the right border.\n      let hitLeft = false, hitMid = false, hitRight = false, colorCount = 0;\n      // Loop over each pixel\n      for (var imgX = 0; imgX < image.bitmap.width; imgX++) {\n        // Check the pixel color, see if it matches the border color (always [0])\n        if (image.getPixelColor(imgX, imgY) === palette[0]) {\n          colorCount++;\n          if (!hitLeft) { // If we haven't seen this before, this is the lefthand side\n            hitLeft = true;\n          } else if (hitMid) { // If we have seen this before, and we also have seen middle pixels, this is the end of the bush on this row\n            hitRight = true;\n          }\n        } else { // Not a border color\n          if (hitLeft && image.getPixelColor(imgX, imgY) === palette[3]) { // If this is filled with background right now, mark it as middle\n            hitMid = true;\n          }\n          if (hitMid && !hitRight && colorCount < 5) { // Based on the variables we set above, if we are in the middle of the image, set the color\n            image.setPixelColor(palette[tileOpt['Bush Color']], imgX, imgY);\n          }\n        }\n      }\n    }\n\n    // Draw small shadow near the foot of the plant\n    for (let shadowX = x - Math.floor(r/2)+1; shadowX < x + r+1; shadowX++) {\n      image.setPixelColor(palette[0], shadowX, y + r + 1);\n      if (shadowX < x + r) {\n        image.setPixelColor(palette[0], shadowX, y + r);\n      }\n    }\n\n    // Pick a few random spots to draw berries/freckles/whatever\n    let freckleCount = 0;\n    // Limit # of tries to make, to prevent infinite loop\n    for (var i = 0; i < 100; i++) {\n\n      // If we've hit the number of freckles we're supposed to, bail out\n      if (freckleCount >= tileOpt['Freckle Count']) {\n        break;\n      }\n\n      // Find a random spot in the image\n      const fx = Math.floor(Math.random() * (image.bitmap.width)),\n        fy = Math.floor(Math.random() * image.bitmap.height);\n\n      // Make sure it's not already a freckle\n      if (image.getPixelColor(fx,fy) === palette[tileOpt['Bush Color']]) {\n        freckleCount++;\n        // Set this pixel\n        image.setPixelColor(palette[tileOpt['Freckle Color']], fx, fy);\n\n        // If it's larger than 1, also fill 1px to the top/left/right/bottom\n        if (tileOpt['Freckle Size'] > 1) {\n          [[fx-1, fy], [fx+1,fy], [fx, fy-1], [fx, fy+1]].forEach(coords => {\n            const fxx = coords[0], fyy = coords[1];\n            if (image.getPixelColor(fxx, fyy) === palette[tileOpt['Bush Color']]) {\n              image.setPixelColor(palette[tileOpt['Freckle Color']], fxx, fyy);\n            }\n          });\n        }\n      }\n    }\n  }\n\n  static async drawRock(image, tileOpt, palette) {\n\n    // We use a quirk of the image library that clamps pixel locations to the inside to make a rock-like shape, \n    // however this forces us to put it at the bottom of the image. Make a copy of the image we can do this on, \n    // which we will later blit onto the original image.\n    const rockImg = await Jimp.read(image);\n\n    // Draw a standard circle outline based on the width of the rock\n    const r = tileOpt['Rock Size'];\n\n    // Purposely place this towards the bottom of the available space in the image.\n    const x = 8, y = rockImg.bitmap.height - (tileOpt['Rock Size'] - 2);\n    let angle, x1, y1;\n    for (var i = 0; i < 360; i++) {\n      angle = i;\n      x1 = r * Math.cos(angle * Math.PI / 180);\n      y1 = r * Math.sin(angle * Math.PI / 180);\n\n      rockImg.setPixelColor(palette[0], Math.round(x + x1), Math.round(y + y1));\n    }\n\n    // terribly simple color filling algorithm - look at \"drawPlant\" to understand this. \n    for (var imgY = 0; imgY < rockImg.bitmap.height; imgY++) {\n      let hitLeft = false, hitMid = false, hitRight = false, colorCount = 0;\n      for (var imgX = 0; imgX < rockImg.bitmap.width; imgX++) {\n        if (rockImg.getPixelColor(imgX, imgY) === palette[0]) {\n          colorCount++;\n          if (!hitLeft) {\n            hitLeft = true;\n          } else if (hitMid) {\n            hitRight = true;\n          }\n        } else {\n          if (hitLeft && rockImg.getPixelColor(imgX, imgY) === palette[3]) {\n            hitMid = true;\n          }\n          if (hitMid && !hitRight && colorCount < 5) { // Must be on the inside of the circle\n            if ((imgX - imgY) < r - Math.floor(r/1.2)) {\n              rockImg.setPixelColor(palette[tileOpt['Rock Color']], imgX, imgY);\n            } else {\n              rockImg.setPixelColor(palette[tileOpt['Rock Highlight Color']], imgX, imgY);\n            }\n          }\n        }\n      }\n    }\n\n    // okay, the image is done, but not really centered, and in a separate image. \n    // Center and blit it back onto our original to finish.\n    await image.blit(rockImg, 0, -1 - Math.floor((image.bitmap.height / 2) - (tileOpt['Rock Size'])));\n  }\n\n  static async drawLava(image, tileOpt, palette) {\n    // We use Sin calculation to get a \"wavy\" sort of look for the lava\n    const frequency = (tileOpt['Frequency'] / 100),\n      offset = tileOpt['Offset'],\n      waveWidth = tileOpt['Wave Width'];\n\n    // Loop over each row\n    for (let y = 0; y < image.bitmap.width; y++) {\n      // Find where the first wave should start on this row\n      let x = Math.sin((frequency * (Math.abs(y-offset) % image.bitmap.width)) ) * Math.floor(image.bitmap.height / 3);\n\n\n      // Increase X by the wave width repeatedly, and mark them with magic pink so we can use this to change colors later\n      while (x < image.bitmap.width) {\n        // Set a dummy color that we will replace later (magic pink)\n        image.setPixelColor(0xff00ffff, x, y);\n        x += waveWidth;\n      }\n\n      // Loop over every x position, incrementing the palette color each time we hit a magic pink-marked pixel from above\n      let currColor = 1;\n      for (x = 0; x < image.bitmap.width; x++) {\n        if (image.getPixelColor(x, y) === 0xff00ffff) {\n          currColor = 1+((currColor + 1) % 3);\n        }\n        image.setPixelColor(palette[currColor], x, y);\n      }\n    }\n  }\n\n  static async drawSand(image, tileOpt, palette) {\n    // We use Sin calculation to get sand waves here. The logic is very similar to drawLava, check that for documentation.\n    const frequency = (tileOpt['Frequency'] / 100),\n      offset = tileOpt['Offset'],\n      waveWidth = tileOpt['Wave Width'];\n    for (let y = 0; y < image.bitmap.width; y++) {\n      let x = Math.sin((frequency * (Math.abs(y-offset) % image.bitmap.width)) ) * Math.floor(image.bitmap.height / 3);\n\n\n      while (x < image.bitmap.width) {\n        // Set a dummy color to replace\n        image.setPixelColor(0xff00ffff, x, y);\n        x += waveWidth;\n      }\n\n      // Repeat iterating over the whole thing, swapping colors\n      let currColor = 2;\n      for (x = 0; x < image.bitmap.width; x++) {\n        if (image.getPixelColor(x, y) === 0xff00ffff) {\n          currColor = 2+((currColor + 1) % 2);\n        }\n        image.setPixelColor(palette[currColor], x, y);\n      }\n    }\n  }\n\n  static async drawBridge(image, tileOpt, palette) {\n    image.scan(0, 0, image.bitmap.width, image.bitmap.height, (x, y) => {\n      // Draw a simple bridge pattern, filling colors accordingly\n      if (x % (tileOpt['Board Width']+1) === 0 || y < tileOpt['Border Width'] || y > (image.bitmap.width - tileOpt['Border Width'] - 1)) {\n        image.setPixelColor(palette[tileOpt['Separator Color']], x, y);\n      } else {\n        image.setPixelColor(palette[tileOpt['Board Color']], x, y);\n      }\n    })\n  }\n\n  static async drawLadder(image, tileOpt, palette) {\n    image.scan(0, 0, image.bitmap.width, image.bitmap.height, (x, y) => {\n      // Draw a simple ladder pattern, filling colors accordingly.\n      if (y % (tileOpt['Step Width']+1) === 0 || x < tileOpt['Border Width'] || x > (image.bitmap.width - tileOpt['Border Width'] - 1)) {\n        image.setPixelColor(palette[tileOpt['Separator Color']], x, y);\n      } else {\n        image.setPixelColor(palette[tileOpt['Step Color']], x, y);\n      }\n    })\n  }\n\n  static async drawBaseDoor(image, tileOpt, palette) {\n    image.scan(0, 0, image.bitmap.width, 1, (x, y) => image.setPixelColor(palette[0], x, y));\n    image.scan(0, 0, 1, image.bitmap.height, (x, y) => image.setPixelColor(palette[0], x, y));\n    image.scan(image.bitmap.width - 1, 0, image.bitmap.width, image.bitmap.height, (x, y) => image.setPixelColor(palette[0], x, y));\n\n    image.scan(0, 0, image.bitmap.width, image.bitmap.height, (x, y) => {\n      if (x % tileOpt['Panel Width'] === 0) {\n        image.setPixelColor(palette[0], x, y);\n      } else if (image.getPixelColor(x, y) !== palette[0]) {\n        // If we didn't set it above, set it here, to the correct bg color.\n        image.setPixelColor(palette[tileOpt['Door Color']], x, y);\n      }\n    });\n  }\n\n  static async drawDoor(image, tileOpt, palette) {\n    await this.drawBaseDoor(image, tileOpt, palette);\n\n    const knobY = Math.floor((image.bitmap.height / 2) - tileOpt['Knob Width']) + 1;\n    const knobX = image.bitmap.width - 3 - Math.floor(tileOpt['Knob Width'] / 2)\n\n    image.scan(knobX, knobY, tileOpt['Knob Width'], tileOpt['Knob Width'], (x, y) => image.setPixelColor(palette[tileOpt['Knob Color']], x, y));\n  }\n\n  static async drawLockedDoor(image, tileOpt, palette) {\n    await this.drawBaseDoor(image, tileOpt, palette);\n\n    const lockY = Math.floor((image.bitmap.height / 2) - 4 + 1);\n    const lockX = Math.floor(image.bitmap.width / 2) - Math.floor(tileOpt['Lock Width'] / 2);\n\n    image.scan(lockX + Math.floor(tileOpt['Lock Width'] / 2), lockY, 1, tileOpt['Lock Width'] === 5 ? 9 : 8, (x, y) => image.setPixelColor(palette[tileOpt['Lock Color']], x, y));\n    \n    image.scan(lockX, lockY, Math.floor(tileOpt['Lock Width'] / 2), 8, (x, y) => {\n      if (y < 10 || (tileOpt['Lock Width'] === 5 && (x === 7)) ) {\n        image.setPixelColor(palette[tileOpt['Lock Color']], x, y)\n      }\n    });\n    image.scan(lockX + 1 + Math.floor(tileOpt['Lock Width'] / 2), lockY, Math.floor(tileOpt['Lock Width'] / 2), 8, (x, y) => {\n      if (y < 10 || (tileOpt['Lock Width'] === 5 && (x === 9)) ) {\n        image.setPixelColor(palette[tileOpt['Lock Color']], x, y)\n      }\n    });\n  }\n  \n\n  static async drawStairs(image, tileOpt, palette) {\n    // Loop over the whole image\n    image.scan(0, 0, image.bitmap.width, image.bitmap.height, (x, y) => {\n      // Determine how tall the stairs are at this x coordinate\n      let stepHeight = Math.floor((x-1) / tileOpt['Step Width']) * tileOpt['Step Height'];\n\n      // If this is a step,\n      if (\n        // This is on a step border on the x axis (horizontal)\n        x % (tileOpt['Step Width']+1) === 0 || \n        // This is on a step border on the y axis (vertical)\n        y < tileOpt['Border Width'] +  stepHeight || \n        // This is taller than the step height at this y coordinate\n        y > (image.bitmap.width - tileOpt['Border Width'] - 1)\n      ) {\n        image.setPixelColor(palette[tileOpt['Separator Color']], x, y);\n      } else {\n        image.setPixelColor(palette[tileOpt['Step Color']], x, y);\n      }\n    })\n  }\n\n\n  // Helper function, recreates a jimp image, give the base64 representation we use elsewhere.\n  static async imageFromBase64(thisB64) {\n    thisB64 = thisB64.substr(thisB64.indexOf(',')+1);\n    return await Jimp.read(Buffer.from(thisB64, 'base64'));\n  }\n\n  // Generate all images, and stitch them together into one tilemap image\n  static generateFullSet(imageState) {\n    return new Promise((resolve, reject) =>{\n      // Make an image as big as all of our tiles, plus one \"blank\" tile to start\n      new Jimp(IMAGE_WIDTH * (AVAILABLE_TILE_TYPES.length+1), IMAGE_HEIGHT, 0xffffffff, (err, image) =>{\n        if (err) { reject(err); }\n\n        // Force back into async context\n        (async () => {\n\n          // Loop over each available image type\n          for (let i = 0; i < AVAILABLE_TILE_TYPES.length; i++ ) {\n            // Grab the image we have in storage\n            let thisImg = await this.imageFromBase64(imageState[AVAILABLE_TILE_TYPES[i]]);\n            // Slap it on the image at the right position.\n            await image.blit(thisImg, (i+1)*IMAGE_WIDTH, 0);\n          }\n\n\n          return image.getBase64Async('image/png');\n        })().then(resolve, reject);\n\n      });\n\n\n    });\n  }\n\n  // Draw an image made up of the tiles we created, based on a built-in example map\n  static generateMapPreview(imageState) {\n    const width = Math.sqrt(TILE_PREVIEW_MAP.length);\n    return new Promise((resolve, reject) =>{\n      // Dealing with Jimp's weird promise quirks (again)\n      new Jimp(IMAGE_WIDTH * width, IMAGE_HEIGHT * width, 0xffffffff, (err, image) =>{\n        if (err) { reject(err); }\n\n        // Force back into async context\n        (async () => {\n\n          // Build up a lookup table of jimp-usable images from tile name, since we should use all of em\n          let tileImages = {};\n          let drawState = {};\n          for (let i = 0; i < AVAILABLE_TILE_TYPES.length; i++) {\n            let thisB64 = imageState[AVAILABLE_TILE_TYPES[i]];\n            thisB64 = thisB64.substr(thisB64.indexOf(',')+1);\n            tileImages[AVAILABLE_TILE_TYPES[i]] = await this.imageFromBase64(imageState[AVAILABLE_TILE_TYPES[i]]);\n            drawState[AVAILABLE_TILE_TYPES[i]] = false;\n          }\n\n          // Loop over the given map\n          for (var x = 0; x < width; x++) {\n            for (var y = 0; y < width; y++) {\n              // Draw the given tile at its position.\n              const pos = y*width + x;\n              image.blit(tileImages[TILE_PREVIEW_MAP[pos]], x * IMAGE_WIDTH, y * IMAGE_HEIGHT);\n\n              // Track which tiles have been drawn, so we can print a warning if we miss one\n              drawState[TILE_PREVIEW_MAP[pos]] = true;\n            }\n          }\n\n          // Check which tiles were not drawn, print a warning.\n          const notDrawn = AVAILABLE_TILE_TYPES.filter(a => !drawState[a]);\n          if (notDrawn.length > 0) {\n            console.warn('Some tiles were not included in the preview!', notDrawn.join(', '));\n          }\n\n          return image.getBase64Async('image/png');\n        })().then(resolve, reject);\n\n      });\n\n    });\n\n  }\n\n  // This outputs a pattern table usable with the ENS directly, or NES art tools like nesst/nexxt\n  static async generateNesPatternTables(imageState, tileProps, organizeIntoBlocks) {\n    let ppuData = [\n    ];\n\n    // Loop over every tile, and convert it to NES binary format\n    for (var i = 0; i < AVAILABLE_TILE_TYPES.length; i++) {\n      const tileType = AVAILABLE_TILE_TYPES[i],\n        tile = await this.imageFromBase64(imageState[tileType]),\n        tileColorData = new Array(tile.bitmap.width * tile.bitmap.height),\n        paletteColors = paletteData[tileProps[tileType].Palette];\n\n      // Loop over all pixels in this tile, and grab the color\n      tile.scan(0, 0, tile.bitmap.width, tile.bitmap.height, (x, y) => {\n        const color = tile.getPixelColor(x, y);\n        // Then drop the 2-bit value of the color into our array, for later use.\n        tileColorData[x + (y * tile.bitmap.width)] = paletteColors.indexOf(color);\n      });\n\n      // Separate out the two bit values we care about for each pixel, allowing us to build bitplanes\n      let bits0 = tileColorData.map (x => x & 0x01),\n        bits1 = tileColorData.map(x => (x & 0x02) >> 1);\n      \n      // This is kind of gross and confusing. It's basically forcing this: https://wiki.nesdev.com/w/index.php?title=PPU_pattern_tables\n      // Build up two bitplanes for each tile, then, pixel-by-pixel, build them up and reassemble.\n\n      // First build up multiple bitplanes, a left and a right for each 8x8 pixel tile in this thing. tl, tr, bl, br\n      let thisTileBp1a = [], thisTileBp2a = [], thisTileBp1b = [], thisTileBp2b = [],\n        thisTileBp3a = [], thisTileBp3b = [], thisTileBp4a = [], thisTileBp4b = [];\n      \n      // Loop over each of the 4 bitplanes (this feels weird because it is)\n      for (let bitplaneNum = 0; bitplaneNum < 4; bitplaneNum++) {\n\n        // Loop over each row in this tile/bitplane\n        for (let j = 0; j < 8; j++) {\n\n          // In our first pass, add a 0 to all planes, so we can do math to them\n          if (bitplaneNum === 0) {\n            thisTileBp1a.push(0);\n            thisTileBp2a.push(0);\n            thisTileBp3a.push(0);\n            thisTileBp4a.push(0);\n            thisTileBp1b.push(0);\n            thisTileBp2b.push(0);\n            thisTileBp3b.push(0);\n            thisTileBp4b.push(0);\n          }\n\n          // Loop over every pixel in the row, assembling each pixel into its left and right bit\n          for (let k = 0; k < 8; k++) {\n            if (bitplaneNum === 0) {\n              thisTileBp1a[j] += bits0[(j * tile.bitmap.width) + k] << (7 - k);\n              thisTileBp1b[j] += bits1[(j * tile.bitmap.width) + k] << (7 - k);\n            } else if (bitplaneNum === 1) {\n              thisTileBp2a[j] += bits0[(j * tile.bitmap.width) + k + 8] << (7 - k);\n              thisTileBp2b[j] += bits1[(j * tile.bitmap.width) + k + 8] << (7 - k);\n            } else if (bitplaneNum === 2) {\n              thisTileBp3a[j] += bits0[(j * tile.bitmap.width) + k + 128] << (7 - k);\n              thisTileBp3b[j] += bits1[(j * tile.bitmap.width) + k + 128] << (7 - k);\n            } else {\n              thisTileBp4a[j] += bits0[(j * tile.bitmap.width) + k + 128 + 8] << (7 - k);\n              thisTileBp4b[j] += bits1[(j * tile.bitmap.width) + k + 128 + 8] << (7 - k);\n            }\n          }\n        }\n      }\n\n      // Add each bitplane to the tile, in the correct order. \n      // At this point, we just put all the tiles in order, so you'll get top left, top right, bottom left, bottom right all in a row\n      ppuData = [\n        ...ppuData,\n        ...thisTileBp1a,\n        ...thisTileBp1b,\n        ...thisTileBp2a,\n        ...thisTileBp2b,\n        ...thisTileBp3a,\n        ...thisTileBp3b,\n        ...thisTileBp4a,\n        ...thisTileBp4b\n      ];\n    }\n    \n    // Prepend a blank tile, with nothing in it - 64 bytes (4 16 byte 8px tiles)\n    ppuData = [\n      0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0,\n      ...ppuData\n    ]\n\n    // The data is currently in a linear format, where each (16 byte) block is in sequence\n    // not pretty, but easy to work with in some games. If the user wants that, sweet!\n    if (!organizeIntoBlocks) {\n      return new Uint8Array(ppuData);\n    }\n\n    // Okay, we have a little work to do to organize it. NES chr files are 16 by 16, 8px tiles, where each tile \n    // takes up 16 bytes. We have to break up by tile. Note we have to add the extra tile from above into the count.\n    \n    // Build up a new array - we just supply a full 4kb pattern table to make this simple for ourselves.\n    let organizedArray = new Array(4096).fill(0);\n    \n    // loop over all tiles (including our blank one)\n    for (let i = 0; i < AVAILABLE_TILE_TYPES.length+1; i++) {\n\n      // Determine where this tile will fall in our organized map - 2 8x8 tiles on one row, two 8x8 tiles on the next.\n      const x = i % 8,\n        y = Math.floor(i / 8),\n        // Get our position within this new map\n        position = (16/*tile size (bytes)*/ * 16/*row width, in nes tiles*/ * 2/*rows per metatile*/ * y) + (16 * x * 2),\n        // Find the position in the original array\n        originalPosition = (i * 4) * 16;\n\n      // Copy the top 32 bytes (2 tiles) into their new home\n      for (let j = 0; j < 32; j++) {\n        organizedArray[position+j] = ppuData[originalPosition+j];\n      }\n      // Copy the bottom 32 bytes into their new home as well)\n      for (let j = 0; j < 32; j++) {\n        organizedArray[position + (16/* tile size (bytes)*/ * 16 /*row width*/) + j] = ppuData[originalPosition + j + 32];\n      }\n    }\n\n    // Okay, we're finally done!\n    return new Uint8Array(organizedArray);\n\n  }\n}"],"sourceRoot":""}